<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs5BEC2C28{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
			.csE3F655E4{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs508254C{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;text-decoration: none;}
			.cs4B51D5E4{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="phpcms-v960-sql注入"><span class="csDE05BCC">Phpcms v9.6.0 sql</span><span class="csECDA2D3">注入</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一、漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<h2 class="cs868C439D">
			<a name="二、漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Phpcms v9.6.0</span></p><h2 class="cs868C439D">
			<a name="三、复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">这个版本的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">SQL</span><span class="csE3F655E4">注入</span><span class="cs8926E06"> </span><span class="cs9C1B1871">主要在于程序对解密后的数据没有进行过滤，我们来看一下漏洞文件</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/modules/content/down.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。在其</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">init</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法中，从</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">GET</span><span class="cs8926E06"> </span><span class="cs9C1B1871">数据中获取了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">a_k</span><span class="cs8926E06"> </span><span class="cs9C1B1871">的值，该值若能解密成程序规定格式的字符串，则程序继续运行（这里加解密使用的秘钥必须一致，例如这里秘钥为</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">pc_base::load_config(&#39;system&#39;,&#39;auth_key&#39;)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">）。程序将解密后的数据用</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">parse_str</span><span class="cs8926E06"> </span><span class="cs9C1B1871">函数处理，这里又存在变量覆盖问题。然后将可控变量</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$id</span><span class="cs8926E06"> </span><span class="cs9C1B1871">带入数据库查询，我们跟进</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">get_one</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image0.png" width="560" height="193" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs5BEC2C28">get_one</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法调用了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sqls</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法，而在</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sqls</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法中可以明显看到，未过滤的数据直接拼接进了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">SQL</span><span class="cs8926E06"> </span><span class="cs9C1B1871">语句中。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image1.png" width="560" height="177" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">那么现在，我们要解决的问题是：如何构造出加密数据，使得数据能够被正常解密？我们先来看一下</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sys_auth</span><span class="cs8926E06"> </span><span class="cs9C1B1871">函数的代码，其代码位于</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/libs/functions/global.func.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">中。开头我们可以很明显看到，当我们没有指定加解密用的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">key</span><span class="cs8926E06"> </span><span class="cs9C1B1871">时，系统默认使用</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">pc_base::load_config(&#39;system&#39;,&#39;auth_key&#39;)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">作为</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">key</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，这样我们就不用特地去搜索形如</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sys_auth(&#39;xxx&#39;,&#39;ENCODE&#39;,pc_base::load_config(&#39;system&#39;,&#39;auth_key&#39;))</span><span class="cs8926E06"> </span><span class="cs9C1B1871">的代码段，直接搜索形如</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sys_auth(&#39;</span><span class="csE3F655E4">可控字符串</span><span class="cs5BEC2C28">&#39;,&#39;ENCODE&#39;)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">或</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sys_auth(&#39;</span><span class="csE3F655E4">可控字符串</span><span class="cs5BEC2C28">&#39;)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">的代码段即可。（这里搜索这种代码段的目的，是为了找到可利用的点将恶意</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">payload</span><span class="cs8926E06"> </span><span class="cs9C1B1871">进行加密，然后传输给开头</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/modules/content/down.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">文件的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">init</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法进一步利用）</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image2.png" width="560" height="87" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">通过搜索，会发现在</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">set_cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法中使用了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sys_auth($value, &#39;ENCODE&#39;)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，我们可以寻找是否存在可控的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$value</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image3.png" width="560" height="250" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">我们可以搜到</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/modules/wap/index.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">文件，在该文件中</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_GET[&#39;siteid&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">可控，并且可以通过</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">获得加密后的数据，但是这里有</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">intval</span><span class="cs8926E06"> </span><span class="cs9C1B1871">过滤，所以无法放置我们的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">payload</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image4.png" width="560" height="212" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">我们继续寻找，会发现</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/modules/attachment/attachments.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">文件的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">swfupload_json</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法有满足我们需要的代码。程序将可控数据放在了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，其中可控数据中，比较好利用的是</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_GET[&#39;src&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image5.png" width="560" height="219" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs5BEC2C28">$_GET[&#39;src&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">只是经过了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">safe_replace</span><span class="cs8926E06"> </span><span class="cs9C1B1871">函数的过滤，该函数会将某些字符替换为空，而我们却可以在</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">payload</span><span class="cs8926E06"> </span><span class="cs9C1B1871">中插入这些字符，从而绕过黑名单的过滤。</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">safe_replace</span><span class="cs8926E06"> </span><span class="cs9C1B1871">函数代码如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image6.png" width="560" height="238" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">貌似现在已经找到了利用链了？别高兴的太早。在调用这个</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">swfupload_json</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法之前，程序会执行</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">attachments</span><span class="cs8926E06"> </span><span class="cs9C1B1871">类的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">__construct</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法，而这个方法中有用户登录状态检测。用于登录状态检测的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$this-&gt;userid</span><span class="cs8926E06"> </span><span class="cs9C1B1871">可以来自</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sys_auth($_POST[&#39;userid_flash&#39;],&#39;DECODE&#39;)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，即我们让</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_POST[&#39;userid_flash&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">经过</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">sys_auth</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法解密之后有东西即可。而这个加密数据，就可以利用我们上面说到的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/modules/wap/index.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">文件。通过</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">获取</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_GET[&#39;siteid&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">加密后的数据，然后再作为</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_POST[&#39;userid_flash&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">的值，即可绕过登录检测。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image7.png" width="560" height="216" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">绕过登录检测后，我们将</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">payload</span><span class="cs8926E06"> </span><span class="cs9C1B1871">传给</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/modules/attachment/attachments.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">文件</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">swfupload_json</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法中的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_GET[&#39;src&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，再利用开头</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">parse_str</span><span class="cs8926E06"> </span><span class="cs9C1B1871">函数进行变量覆盖，最终完成整个漏洞链。整个漏洞的利用流程图如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image8.png" width="560" height="401" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">按照默认配置安装的网站搭建好后，</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">WAP</span><span class="cs8926E06"> </span><span class="cs9C1B1871">是处于禁用状态，但是这并不影响我们获得加密后的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_GET[&#39;siteid&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image9.png" width="560" height="130" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image10.png" width="560" height="132" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">我们再来假设，如果网站管理员删除了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">WAP</span><span class="cs8926E06"> </span><span class="cs9C1B1871">模块的代码，这个洞还能利用吗？我们可以继续来挖掘一下这个漏洞链的其他入口，这也是网络上未公开的一个入口点。上面我们在搜索</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">set_cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法找可控数据时，会发现</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">phpcms/modules/mood/index.php</span><span class="cs8926E06"> </span><span class="cs9C1B1871">文件的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">post</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法可以直接获得一个加密后的数据，这样我们就可以将这个数据，用在漏洞链的第二步：绕过用户登录验证，具体代码如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image11.png" width="560" height="267" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里只要按照代码逻辑，构造参数即可。这里可能还要注意本类的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">__construct</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法，同样按照逻辑构造参数即可，具体构造这里不再赘述。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image12.png" width="560" height="235" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">通过上面这个漏洞链入口，我们便可以进行</span><span class="cs8926E06"> </span><span class="csE3F655E4">报错</span><span class="cs5BEC2C28">SQL</span><span class="csE3F655E4">注入</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。比较有意思的是，</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">PHPCMS</span><span class="cs8926E06"> </span><span class="cs9C1B1871">会将</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">admin</span><span class="cs8926E06"> </span><span class="cs9C1B1871">登录的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">存储在数据库中，我们可以通过注入获取管理员</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，然后伪造管理员身份利用后台</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">getshell</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。这里如何伪造身份，网络上貌似提及很少，唯一找到一篇文章</span><span class="cs8926E06"><a class="cs508254C" href="https://www.secpulse.com/archives/57486.html"><span class="cs4B51D5E4">https://www.secpulse.com/archives/57486.html</span></a></span><span class="cs8926E06"> </span><span class="cs9C1B1871">，发现作者竟然还少提及了一个关键参数。于是我将伪造的数据包，与正常登录的数据包进行对比，逐个删除</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">中的数据，看看少了哪个关键参数。接下来，我们来具体看一下如何伪造</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">进入后台。</span></p><p class="cs40DD2BC9"><span class="cs5BEC2C28">PHPCMS</span><span class="cs8926E06"> </span><span class="cs9C1B1871">专门在数据库中建了一个表来存放</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">PHPSESSID</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，其中也包含管理员的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">PHPSESSID</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，且登录状态下的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">userid</span><span class="cs8926E06"> </span><span class="cs9C1B1871">字段会被设为</span><span class="cs8926E06">1</span><span class="cs9C1B1871">，注销则为</span><span class="cs8926E06">0</span><span class="cs9C1B1871">，具体如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image13.png" width="560" height="193" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">我们把</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">PHPSESSID=9t9mrk25ak5sb9v60nc255ql11</span><span class="cs8926E06"> </span><span class="cs9C1B1871">加到</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">中，直接访问后台，这是发现程序还是会让你登录，估计我们是少了什么，下面来动态调试一下。经过调试，我们会发现程序终止在了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">admin</span><span class="cs8926E06"> </span><span class="cs9C1B1871">类</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">__construct</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">self::check_admin()</span><span class="cs8926E06"> </span><span class="cs9C1B1871">语句中，其具体代码如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image14.png" width="560" height="132" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可以明显看到，我们原先的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">中少了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$userid</span><span class="cs8926E06"> </span><span class="cs9C1B1871">对应的字段，而且要想绕过登录，必须保证</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$_SESSION[&#39;roleid&#39;]</span><span class="cs8926E06"> </span><span class="cs9C1B1871">和</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$userid</span><span class="cs8926E06"> </span><span class="cs9C1B1871">相等且它们两者非空。那么现在，我们只要加上</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">$userid</span><span class="cs8926E06"> </span><span class="cs9C1B1871">对应字段就行了，其值可以从上面漏洞链第一步中的响应包</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">Set-Cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">字段获取。这里要注意一个点，一旦管理员注销，我们就无法利用这个点伪造</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">cookie</span><span class="cs8926E06"> </span><span class="cs9C1B1871">了，这也是这个漏洞的鸡肋之处。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">最后来看一下官方发布的</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">PHPCMS v9.6.1</span><span class="cs8926E06"> </span><span class="cs9C1B1871">中是如何修复这个漏洞的，补丁如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Phpcms/Phpcms%20v9.6.0%20sql%e6%b3%a8%e5%85%a5_files/image15.png" width="560" height="226" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可以看到官方对解密后的数据进行了</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">safe_replace</span><span class="csE3F655E4">、</span><span class="cs5BEC2C28">intval</span><span class="cs8926E06"> </span><span class="cs9C1B1871">双重过滤处理。</span></p><h2 class="cs868C439D">
			<a name="参考链接"><span class="cs83F14626">参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06"><a class="cs508254C" href="https://xz.aliyun.com/t/5730"><span class="cs4B51D5E4">https://xz.aliyun.com/t/5730</span></a></span></p></body>
</html>
