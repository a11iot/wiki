<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs6EDCDAE2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:italic;}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs24C36B3{text-align:left;margin:0pt 0pt 10pt 0pt;list-style-type:disc;color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal}
			.csC0D0424F{text-align:left;margin:0pt 0pt 10pt -12pt;list-style-type:lower-latin;color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="cve-2020-11989apache-shiro--153-身份认证绕过漏洞"><span class="csECDA2D3">（</span><span class="csDE05BCC">CVE-2020-11989</span><span class="csECDA2D3">）</span><span class="csDE05BCC">Apache Shiro &lt; 1.5.3 </span><span class="csECDA2D3">身份认证绕过漏洞</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Apache Shiro &lt; 1.5.3</span></p><p class="cs40DD2BC9"><span class="cs8926E06">Spring </span><span class="cs9C1B1871">框架中只使用</span><span class="cs8926E06"> Shiro </span><span class="cs9C1B1871">鉴权</span></p><h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<h3 class="cs868C439D">
			<a name="一双重编码绕过"><span class="csD6CA00D2">（一）双重编码绕过</span></a></h3>
		<h4 class="cs868C439D">
			<a name="双重编码绕过分析"><span class="cs6EDCDAE2">双重编码绕过分析</span></a></h4>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">当我们的请求进入应用后会进行第一次的</span><span class="cs8926E06">url</span><span class="cs9C1B1871">解码</span></p><p class="cs3A447A38"><span class="cs9FB05234">%25%32%66 -&gt; %2f</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> </span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">接着当进入到</span><span class="cs8926E06">shiro</span><span class="cs9C1B1871">的</span><span class="cs8926E06"> </span><span class="cs9FB05234">org.apache.shiro.web.util.WebUtils#getPathWithinApplication</span><span class="cs8926E06"> </span><span class="cs9C1B1871">采用的是</span><span class="cs8926E06"> </span><span class="cs9FB05234">getRequestUri</span><span class="cs8926E06"> </span><span class="cs9C1B1871">方法同时里面会调用到</span><span class="cs8926E06"> </span><span class="cs9FB05234">decodeRequestString</span><span class="cs8926E06"> </span><span class="cs9C1B1871">进行再一次的解码。</span></p><p class="cs40DD2BC9"><span class="cs8926E06">3.jpg</span></p><p class="cs3A447A38"><span class="cs9FB05234">%2f -&gt; /</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> </span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可以看到这里就造成了和</span><span class="cs8926E06">Spring</span><span class="cs9C1B1871">的</span><span class="cs8926E06">uri</span><span class="cs9C1B1871">处理不一致的问题，也就导致了接下来的问题。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">当进入到</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">org.apache.shiro.util.AntPathMatcher#doMatch</span><span class="cs8926E06"> </span><span class="cs9C1B1871">去匹配是否符合我们之前定义的权限路由</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">/hello/*</span></p><p class="cs40DD2BC9"><span class="cs8926E06">4.jpg</span></p><p class="cs40DD2BC9"><span class="cs9FB05234">doMatch</span><span class="cs8926E06"> </span><span class="cs9C1B1871">的代码有点杂这里就不放了，感兴趣的可以自己去跟一下逻辑。简单来说就是这里可以看到</span><span class="cs8926E06">path</span><span class="cs9C1B1871">成了</span><span class="cs8926E06"> </span><span class="cs9FB05234">/hello/a/a</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，</span><span class="cs8926E06">hello</span><span class="cs9C1B1871">后有两个</span><span class="cs8926E06"> </span><span class="cs9FB05234">/</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，所以跳过了这次的判断，导致了身份验证绕过。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">总结一下，当进入应用后我们的请求页面被解析成</span><span class="cs8926E06"> </span><span class="cs9FB05234">/hello/a%2fa</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，所以它可以进入到</span><span class="cs8926E06">springcontroller</span><span class="cs9C1B1871">中的</span><span class="cs8926E06"> </span><span class="cs9FB05234">/hello/{name}</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">但是因为</span><span class="cs8926E06">shiro</span><span class="cs9C1B1871">再次做了</span><span class="cs8926E06">url</span><span class="cs9C1B1871">解码，导致判断的</span><span class="cs8926E06">uri</span><span class="cs9C1B1871">成为了</span><span class="cs8926E06"> </span><span class="cs9FB05234">/hello/a/a</span><span class="cs8926E06"> </span><span class="cs9C1B1871">它不属于我们配置的权限判断地址</span><span class="cs8926E06"> </span><span class="cs9FB05234">/hello/*</span><span class="cs8926E06"> </span><span class="cs9C1B1871">。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">因此造成了绕过，核心原理可以归因为是</span><span class="cs8926E06">shiro</span><span class="cs9C1B1871">与</span><span class="cs8926E06">spring</span><span class="cs9C1B1871">对</span><span class="cs8926E06">RFC</span><span class="cs9C1B1871">标准实现的差异导致（实际上就是</span><span class="cs8926E06">shiro</span><span class="cs9C1B1871">实现错了）。</span></p><h4 class="cs868C439D">
			<a name="双重编码绕过复现"><span class="cs6EDCDAE2">双重编码绕过复现</span></a></h4>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">编写如下代码</span></p><p class="cs3A447A38"><span class="cs9FB05234">@Configuration</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">public class ShiroConfig {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;@Bean</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;MyRealm myRealm() {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyRealm();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> </span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;@Bean</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;SecurityManager securityManager() {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DefaultWebSecurityManager manager = new DefaultWebSecurityManager();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.setRealm(myRealm());</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return manager;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> </span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;@Bean</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;ShiroFilterFactoryBean shiroFilterFactoryBean() {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean.setSecurityManager(securityManager());</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean.setLoginUrl(&quot;/login&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean.setSuccessUrl(&quot;/index&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean.setUnauthorizedUrl(&quot;/unauthorizedurl&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(&quot;/hello/*&quot;, &quot;authc&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean.setFilterChainDefinitionMap(map);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return bean;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里我配置了</span></p><p class="cs3A447A38"><span class="cs9FB05234">map.put(&quot;/hello/*&quot;, &quot;authc&quot;);</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">同时我编写了对应的</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">像这样</span></p><p class="cs3A447A38"><span class="cs9FB05234">@GetMapping(&quot;/hello/{name}&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">public String hello(@PathVariable String name) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;return &quot;hello&quot;;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> </span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">以上操作代表着我通过</span><span class="cs8926E06">ant</span><span class="cs9C1B1871">风格的语法设置了去检查在访问</span><span class="cs8926E06"> </span><span class="cs9FB05234">/hello</span><span class="cs8926E06"> </span><span class="cs9C1B1871">路由之后的一级目录的用户是否有权限。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">如果你请求</span><span class="cs8926E06"> </span><span class="cs9FB05234">/hello/aaa</span><span class="cs8926E06"> </span><span class="cs9C1B1871">那么你将会被禁止。</span></p><p class="cs40DD2BC9"><span class="cs8926E06">1.jpg</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">但是这里我们可以通过</span><span class="cs8926E06">url</span><span class="cs9C1B1871">双编码来绕过。</span></p><p class="cs3A447A38"><span class="cs9FB05234">/ -&gt; %2f -&gt;%25%32%66</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">GET /hello/a%25%32%66a HTTP/1.1</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Host: www.0-sec.org:8080</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Connection: close</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Upgrade-Insecure-Requests: 1</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> </span></p><p class="cs40DD2BC9"><span class="cs8926E06">2.jpg</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">现在它成功了</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">当然这个漏洞需要一些限制条件，首先权限</span><span class="cs8926E06">ant</span><span class="cs9C1B1871">风格的配置需要是</span><span class="cs8926E06"> </span><span class="cs9FB05234">*</span><span class="cs8926E06"> </span><span class="cs9C1B1871">而不是</span><span class="cs8926E06"> </span><span class="cs9FB05234">**</span><span class="cs8926E06"> </span><span class="cs9C1B1871">，同时</span><span class="cs8926E06">controller</span><span class="cs9C1B1871">需要接收的</span><span class="cs8926E06">request</span><span class="cs9C1B1871">参数</span><span class="cs8926E06">(@PathVariable)</span><span class="cs9C1B1871">的类型需要是</span><span class="cs8926E06">String</span><span class="cs9C1B1871">，否则将会出错。</span></p><h3 class="cs868C439D">
			<a name="二分号绕过"><span class="csD6CA00D2">（二）分号绕过</span></a></h3>
		<h4 class="cs868C439D">
			<a name="分号绕过分析"><span class="cs6EDCDAE2">分号绕过分析</span></a></h4>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">由于</span><span class="cs8926E06">Shiro</span><span class="cs9C1B1871">的权限校验是通过判断</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">匹配来做的，如果能找到</span><span class="cs8926E06"> Shiro </span><span class="cs9C1B1871">获取的</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">与</span><span class="cs8926E06"> Web </span><span class="cs9C1B1871">框架处理</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">不一致的情况就能造成权限绕过。</span><span class="cs8926E06">Shiro </span><span class="cs9C1B1871">中对于</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">的获取及匹配在</span></p><p class="cs40DD2BC9"><span class="cs8926E06">org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">以访问</span><span class="cs8926E06"> /;/test/admin/page </span><span class="cs9C1B1871">举例，通过</span><span class="cs8926E06"> getPathWithinApplication </span><span class="cs9C1B1871">函数得到的路径为</span><span class="cs8926E06"> /</span></p><p class="cs40DD2BC9"><span class="cs8926E06">1.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">跟入该函数的处理逻辑</span><span class="cs8926E06">org.apache.shiro.web.util.WebUtils#getPathWithinApplication</span></p><p class="cs40DD2BC9"><span class="cs8926E06">2.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可以看到</span><span class="cs8926E06"> org.apache.shiro.web.util.WebUtils#getRequestUri </span><span class="cs9C1B1871">获取到的是</span><span class="cs8926E06"> /</span></p><p class="cs40DD2BC9"><span class="cs8926E06">3.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里分别通过</span><span class="cs8926E06"> getContextPath() getServletPath() getPathInfo() </span><span class="cs9C1B1871">获取并拼接得到</span><span class="cs8926E06"> /;/test//admin/page </span><span class="cs9C1B1871">，传入后</span><span class="cs8926E06"> decodeAndCleanUriString </span><span class="cs9C1B1871">变成了</span><span class="cs8926E06"> / , org.apache.shiro.web.util.WebUtils#decodeAndCleanUriString</span></p><p class="cs40DD2BC9"><span class="cs8926E06">4.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在</span><span class="cs8926E06"> decodeAndCleanUriString </span><span class="cs9C1B1871">，会根据</span><span class="cs8926E06"> Ascii </span><span class="cs9C1B1871">为</span><span class="cs8926E06"> 59 </span><span class="cs9C1B1871">的字符也就是</span><span class="cs8926E06"> ; </span><span class="cs9C1B1871">进行</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">的截断，所以最终返回了</span><span class="cs8926E06"> /</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">回到最开始的</span><span class="cs8926E06"> /;/test/admin/page </span><span class="cs9C1B1871">请求，该</span><span class="cs8926E06"> request </span><span class="cs9C1B1871">请求会进入</span><span class="cs8926E06"> Spring </span><span class="cs9C1B1871">中，</span><span class="cs8926E06"> Spring </span><span class="cs9C1B1871">处理</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">函数如下</span><span class="cs8926E06">org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping<br/>5.png</span></p><p class="cs40DD2BC9"><span class="cs8926E06">7.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在</span><span class="cs8926E06"> getPathWithinApplication </span><span class="cs9C1B1871">处理下是能正确获取到</span><span class="cs8926E06"> context-path </span><span class="cs9C1B1871">与路由，最终经过</span><span class="cs8926E06"> getPathWithinServletMapping </span><span class="cs9C1B1871">函数格式化处理后，得到最终路径为</span><span class="cs8926E06"> /admin/page </span><span class="cs9C1B1871">，所以我们可以正常访问到该页面</span></p><p class="cs40DD2BC9"><span class="cs8926E06">6.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">因此总结来说就是当</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">进入到</span><span class="cs8926E06"> Tomcat </span><span class="cs9C1B1871">时，</span><span class="cs8926E06"> Tomcat </span><span class="cs9C1B1871">判断</span><span class="cs8926E06"> /;test/admin/page </span><span class="cs9C1B1871">为</span><span class="cs8926E06"> test </span><span class="cs9C1B1871">应用下的</span><span class="cs8926E06"> /admin/page </span><span class="cs9C1B1871">路由，进入到</span><span class="cs8926E06"> Shiro </span><span class="cs9C1B1871">时被</span><span class="cs8926E06"> ; </span><span class="cs9C1B1871">截断被认作为</span><span class="cs8926E06"> / ,</span><span class="cs9C1B1871">再进入</span><span class="cs8926E06"> Spring </span><span class="cs9C1B1871">时又被正确处理为</span><span class="cs8926E06"> test </span><span class="cs9C1B1871">应用下的</span><span class="cs8926E06"> /admin/page </span><span class="cs9C1B1871">路由，最后导致</span><span class="cs8926E06"> Shiro </span><span class="cs9C1B1871">的权限绕过。</span></p><h4 class="cs868C439D">
			<a name="分号绕过复现"><span class="cs6EDCDAE2">分号绕过复现</span></a></h4>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">测试</span><span class="cs8926E06"> Demo </span><span class="cs9C1B1871">：</span></p><p class="cs3A447A38"><span class="cs9FB05234">https://github.com/ianxtianxt/springboot-shiro</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">权限配置如下，其中</span><span class="cs8926E06"> /admin </span><span class="cs9C1B1871">下的路由需要登录才能访问</span></p><p class="cs3A447A38"><span class="cs9FB05234">@Bean</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">ShiroFilterFactoryBean shiroFilterFactoryBean(){</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;bean.setSecurityManager(securityManager());</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;bean.setLoginUrl(&quot;/login&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;bean.setSuccessUrl(&quot;/index&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;bean.setUnauthorizedUrl(&quot;/unauthorizedurl&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;map.put(&quot;/doLogin&quot;, &quot;anon&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;map.put(&quot;/admin/*&quot;, &quot;authc&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;bean.setFilterChainDefinitionMap(map);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;return &nbsp;bean;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">---</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">@GetMapping(&quot;/admin/page&quot;)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">public String admin() {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;return &quot;admin page&quot;;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs8926E06">maven </span><span class="cs9C1B1871">打包项目为</span><span class="cs8926E06"> test.war </span><span class="cs9C1B1871">，部署于</span><span class="cs8926E06"> Tomcat </span><span class="cs9C1B1871">。该漏洞成功利用存在下面两个条件</span></p><ul style="margin-top:0;margin-bottom:0;">
			<li class="cs24C36B3"><span class="cs8926E06">1.</span><span class="cs9C1B1871">应用不能部署在根目录，也就是需要</span><span class="cs8926E06"> context-path </span><span class="cs9C1B1871">，</span><span class="cs8926E06"> server.servlet.context-path=/test ,</span><span class="cs9C1B1871">如果为根目录则</span><span class="cs8926E06"> context-path </span><span class="cs9C1B1871">为空，就会被</span><span class="cs8926E06"> CVE-2020-1957 </span><span class="cs9C1B1871">的</span><span class="cs8926E06"> patch </span><span class="cs9C1B1871">将</span><span class="cs8926E06"> URL </span><span class="cs9C1B1871">格式化，值得注意的是若</span><span class="cs8926E06"> Shiro </span><span class="cs9C1B1871">版本小于</span><span class="cs8926E06"> 1.5.2 </span><span class="cs9C1B1871">的话那么该条件就不需要。</span></li></ul>
		<ol style="margin-top:0;margin-bottom:0;">
			<ol style="margin-top:0;margin-bottom:0;">
				<li class="csC0D0424F" value="2"><span class="cs8926E06">Spring </span><span class="cs9C1B1871">控制器中没有另外的权限校验代码</span></li></ol>
		</ol>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">如果直接访问</span><span class="cs8926E06"> </span><span class="cs9FB05234">/test/admin/page </span><span class="cs9C1B1871">，会返回</span><span class="cs8926E06">302</span><span class="cs9C1B1871">跳转要求登录</span><span class="cs8926E06"><br/>8.png</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">但是访问</span><span class="cs9FB05234">/;/test/admin/page </span><span class="cs8926E06">, </span><span class="cs9C1B1871">就能直接绕过</span><span class="cs8926E06"> Shiro </span><span class="cs9C1B1871">权限验证，访问到</span><span class="cs8926E06"> /admin </span><span class="cs9C1B1871">路由中的信息</span></p><p class="cs40DD2BC9"><span class="cs8926E06">9.png</span></p><h2 class="cs868C439D">
			<a name="参考链接"><span class="cs83F14626">参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06">http://www.liuhaihua.cn/archives/694110.html</span></p><p class="cs6FD73CFB"><span class="cs8926E06">https://mp.weixin.qq.com/s/yb6Tb7zSTKKmBlcNVz0MBA</span></p></body>
</html>
