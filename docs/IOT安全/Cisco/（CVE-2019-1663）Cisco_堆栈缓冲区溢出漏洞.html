<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.csAD577193{text-align:left;text-indent:0pt;margin:24pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.csECDA2D3{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:16pt;font-weight:bold;font-style:normal;}
			.csDE05BCC{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:16pt;font-weight:bold;font-style:normal;}
			.cs868C439D{text-align:left;text-indent:0pt;margin:10pt 0pt 0pt 0pt;page-break-after:avoid;page-break-inside:avoid}
			.cs83F14626{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs40DD2BC9{text-align:left;text-indent:0pt;margin:9pt 0pt 9pt 0pt}
			.cs8926E06{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
			.cs9C1B1871{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:normal;font-style:normal;}
			.csD1E291E2{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
			.csD6CA00D2{color:#4F81BD;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs3A447A38{text-align:left;text-indent:0pt;margin:0pt 0pt 10pt 0pt}
			.cs9FB05234{color:#000000;background-color:transparent;font-family:Consolas;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs7FFD2630{color:#000000;background-color:transparent;font-family:Microsoft JhengHei UI;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs98083A41{color:#000000;background-color:transparent;font-family:MS Gothic;font-size:11pt;font-weight:normal;font-style:normal;}
			.cs5BEC2C28{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:bold;font-style:normal;}
			.csE3F655E4{color:#000000;background-color:transparent;font-family:Microsoft YaHei UI;font-size:12pt;font-weight:bold;font-style:normal;}
			.cs6FD73CFB{text-align:left;text-indent:0pt;margin:5pt 24pt 5pt 24pt}
			.cs508254C{color:#000000;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;text-decoration: none;}
			.cs4B51D5E4{color:#4F81BD;background-color:transparent;font-family:Calibri;font-size:12pt;font-weight:normal;font-style:normal;}
		</style>
	</head>
	<body>
		<h1 class="csAD577193">
			<a name="X75462778c5df33e5c98a3d05f7e1bdf2f6338e1"><span class="csECDA2D3">（</span><span class="csDE05BCC">CVE-2019-1663</span><span class="csECDA2D3">）堆栈缓冲区溢出漏洞</span></a></h1>
		<h2 class="cs868C439D">
			<a name="一、漏洞简介"><span class="cs83F14626">一、漏洞简介</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">CVE-2019-1663</span><span class="cs9C1B1871">是一个影响</span><span class="cs8926E06">Cisco</span><span class="cs9C1B1871">的多个低端设备的堆栈缓冲区，由于管理界面没有对登录表单的</span><span class="cs8926E06">pwd</span><span class="cs9C1B1871">字段进行严格的过滤，底层在处理请求时，</span><span class="cs8926E06">strcpy</span><span class="cs9C1B1871">函数导致堆栈溢出，未经身份验证的远程攻击者可以在设备上执行任意代码</span></p><h2 class="cs868C439D">
			<a name="二、漏洞影响"><span class="cs83F14626">二、漏洞影响</span></a></h2>
		<p class="cs40DD2BC9"><span class="cs8926E06">Cisco RV110W &lt;1.2.1.7 Cisco RV130/RV130W &lt; 1.0.3.45 Cisco RV215W &lt;1.3.0.8</span></p><h2 class="cs868C439D">
			<a name="三、复现过程"><span class="cs83F14626">三、复现过程</span></a></h2>
		<h3 class="cs868C439D">
			<a name="X44c8625bedfbf6bf17fbe93ed4e1580e1f791d3"><span class="csD1E291E2">0x01 </span><span class="csD6CA00D2">固件提取</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">这里我使用时</span><span class="cs8926E06">Cisco RV130W 1.0.3.44</span><span class="cs9C1B1871">进行测试的，</span><span class="cs8926E06">binwalk</span><span class="cs9C1B1871">对固件进行提取</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image0.png" width="560" height="347" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">可以看出文件系统是</span><span class="cs8926E06">squashfs,</span><span class="cs9C1B1871">并且是小端存储方式</span><span class="cs8926E06">,</span><span class="cs9C1B1871">得到一个类</span><span class="cs8926E06">Linux</span><span class="cs9C1B1871">目录</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image1.png" width="560" height="25" alt="" style="border-width:0px;" /></span></p><h3 class="cs868C439D">
			<a name="X84134734d79b2759cfa55245ea9e84bd0253ed5"><span class="csD1E291E2">0x02 </span><span class="csD6CA00D2">分析处理请求</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">使用</span><span class="cs8926E06"> grep -r &ldquo;http&rdquo;</span><span class="cs9C1B1871">来查找处理</span><span class="cs8926E06">http</span><span class="cs9C1B1871">请求的二进制文件</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image2.png" width="560" height="305" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">根据之前分析的多个嵌入式设备的经验，猜测这个可能就是处理</span><span class="cs8926E06">http</span><span class="cs9C1B1871">请求的底层文件</span></p><h3 class="cs868C439D">
			<a name="Xa8839dd6ee0f6f086c32bbb4f8a05e5fe193fa0"><span class="csD1E291E2">0x03 </span><span class="csD6CA00D2">漏洞分析</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">对</span><span class="cs8926E06">Web</span><span class="cs9C1B1871">登录界面的</span><span class="cs8926E06">login.cgi</span><span class="cs9C1B1871">发送如下的</span><span class="cs8926E06">POST</span><span class="cs9C1B1871">请求</span></p><p class="cs3A447A38"><span class="cs9FB05234">POST /login.cgi HTTP/1.1</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Host: 10.10.10.2</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Accept-Language: en-US,en;q=0.5</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Accept-Encoding: gzip, deflate</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Referer: https://10.10.10.2/</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Content-Type: application/x-www-form-urlencoded</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Content-Length: 137</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Connection: close</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Upgrade-Insecure-Requests: 1</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">submit_button=login&amp;submit_type=&amp;gui_action=&amp;wait_time=0&amp;change_action=&amp;enc=1&amp;user=cisco&amp;pwd=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&amp;sel_lang=EN</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里向</span><span class="cs8926E06">pwd</span><span class="cs9C1B1871">发送</span><span class="cs8926E06">32</span><span class="cs9C1B1871">字节的值，对登录界面的</span><span class="cs8926E06">http</span><span class="cs9C1B1871">处理请求在</span><span class="cs8926E06">IDA</span><span class="cs9C1B1871">中的是</span><span class="cs8926E06">sub_2C614()</span><span class="cs9C1B1871">，地址是</span><span class="cs8926E06">0x0002C614</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image3.png" width="560" height="937" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">函数将</span><span class="cs8926E06">POST</span><span class="cs9C1B1871">请求的参数进行解析，存储到</span><span class="cs8926E06">.bss</span><span class="cs9C1B1871">段</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image4.png" width="560" height="255" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后，将</span><span class="cs8926E06">pwd</span><span class="cs9C1B1871">参数的值从</span><span class="cs8926E06">.bss</span><span class="cs9C1B1871">段中提取，调用</span><span class="cs8926E06">strcpy</span><span class="cs9C1B1871">将值存到动态分配的内存中</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image5.png" width="560" height="199" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">对于</span><span class="cs8926E06">strcpy</span><span class="cs9C1B1871">我们都很熟悉，它存在的安全问题也十分严峻，并且由于没有开启</span><span class="cs8926E06">PIE / ASLR</span><span class="cs9C1B1871">，所以可以随意的进行溢出操作</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里使用</span><span class="cs8926E06">gdb</span><span class="cs9C1B1871">进行远程调试，确定能够发生溢出的字节数，首先设置</span><span class="cs8926E06">cisco,</span><span class="cs9C1B1871">作为</span><span class="cs8926E06">gdb</span><span class="cs9C1B1871">调试的服务端，</span><span class="cs8926E06">gdbserver</span><span class="cs9C1B1871">配置</span></p><p class="cs3A447A38"><span class="cs9FB05234"># wget http://10.10.10.1:8000/gdbserver //</span><span class="cs7FFD2630">从本机下载到</span><span class="cs9FB05234">qemu</span><span class="cs7FFD2630">模拟的</span><span class="cs9FB05234">cisco</span><span class="cs7FFD2630">环境中</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">#chmod 777 ./gdbserver &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span><span class="cs7FFD2630">给权限</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># ps -w | grep httpd &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span><span class="cs7FFD2630">查找</span><span class="cs9FB05234">httpd</span><span class="cs7FFD2630">开启的进程号</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> 2451 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5472 S &nbsp;&nbsp;./usr/sbin/httpd </span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> 2454 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1196 S &nbsp;&nbsp;grep httpd </span><span class="cs8926E06"><br/></span><span class="cs9FB05234"># ./gdbserver :1234 --attach 2451 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span><span class="cs7FFD2630">这里的</span><span class="cs9FB05234">1234</span><span class="cs7FFD2630">是开启监听的端口号，</span><span class="cs9FB05234">--attach</span><span class="cs7FFD2630">添加的是</span><span class="cs9FB05234">httpd</span><span class="cs7FFD2630">的进程号</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Attached; pid = 2451</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Listening on port 1234</span><span class="cs8926E06"><br/></span><span class="cs9FB05234"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span><span class="cs7FFD2630">然后成功监听</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">编译</span><span class="cs8926E06">arm-gdb-linux</span></p><p class="cs3A447A38"><span class="cs9FB05234">tar xvf gdb-7.8.1.tar.gz</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">cd gdb-7.8.1</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">mkdir arm-gdb</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">sudo chmod 777 arm-gdb</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">sudo apt-get install texinfo</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">./configure --target=arm-linux &nbsp;--prefix=/home/clb/1tools/gdb-7.8.1/arm-gdb</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">make &amp;&amp; make install</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">然后在</span><span class="cs8926E06">arm-gdb</span><span class="cs9C1B1871">下的</span><span class="cs8926E06">bin</span><span class="cs9C1B1871">目录中就有用于调试的</span><span class="cs8926E06">arm-linux-gdb</span><span class="cs9C1B1871">，配置调试选项</span></p><p class="cs3A447A38"><span class="cs9FB05234">./arm-linux-gdb </span><span class="cs8926E06"><br/></span><span class="cs9FB05234">gef&gt; set architecture arm &nbsp;&nbsp;//</span><span class="cs7FFD2630">确定要调试的是</span><span class="cs9FB05234">arm</span><span class="cs7FFD2630">架构</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">gef&gt; set follow-fork-mode child &nbsp;//</span><span class="cs7FFD2630">确定调试的进程</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">gef&gt; set solib-search-path /home/clb/1iot/firmware/cisco/_RV130.bin.extracted/squashfs-root/lib/ //</span><span class="cs7FFD2630">加载要用到的</span><span class="cs9FB05234">lib</span><span class="cs7FFD2630">文件</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">gef&gt; file /home/clb/1iot/firmware/cisco/_RV130.bin.extracted/squashfs-root/usr/sbin/httpd &nbsp;//</span><span class="cs7FFD2630">加载调试文件</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">gef&gt; target remote 10.10.10.2:1234 &nbsp;//</span><span class="cs7FFD2630">与远程建立连接</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">已经建立调试连接，可以进行调试了</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">查找溢出的位置，使用</span><span class="cs8926E06">pattern</span><span class="cs9C1B1871">生成</span><span class="cs8926E06">512</span><span class="cs9C1B1871">个字符串</span></p><p class="cs3A447A38"><span class="cs9FB05234">gef</span><span class="cs98083A41">➤</span><span class="cs9FB05234"> &nbsp;patter create 512</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] Generating a pattern of 512 bytes</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] Saved as &#39;$_gef0&#39;</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">通过</span><span class="cs8926E06">curl</span><span class="cs9C1B1871">发送</span><span class="cs8926E06">POST</span><span class="cs9C1B1871">请求查找溢出的位置</span></p><p class="cs3A447A38"><span class="cs9FB05234">gef</span><span class="cs98083A41">➤</span><span class="cs9FB05234"> &nbsp;c</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">Continuing.</span><span class="cs8926E06"><br/><br/></span><span class="cs9FB05234">Program received signal SIGSEGV, Segmentation fault.</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">0x616d6560 in ?? ()</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">通过</span><span class="cs8926E06">pattern</span><span class="cs9C1B1871">确定溢出的大小</span></p><p class="cs3A447A38"><span class="cs9FB05234">gef</span><span class="cs98083A41">➤</span><span class="cs9FB05234"> &nbsp;pattern search 0x616d6561</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] Searching &#39;0x616d6561&#39;</span><span class="cs8926E06"><br/></span><span class="cs9FB05234">[+] Found at offset 446 (little-endian search) likely</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">我们可以确定要进行填充的字符串是有</span><span class="cs8926E06">446</span><span class="cs9C1B1871">个字节</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里使用</span><span class="cs8926E06">Ret2Libc</span><span class="cs9C1B1871">进行利用。</span><span class="cs5BEC2C28">ret2libc</span><span class="cs8926E06"> </span><span class="cs9C1B1871">这种攻击方式主要是针对</span><span class="cs8926E06"> </span><span class="csE3F655E4">动态链接</span><span class="cs5BEC2C28">(Dynamic linking)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">编译的程序，因为正常情况下是无法在程序中找到像</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">system() </span><span class="csE3F655E4">、</span><span class="cs5BEC2C28">execve()</span><span class="cs8926E06"> </span><span class="cs9C1B1871">这种系统级函数</span><span class="cs8926E06">(</span><span class="cs9C1B1871">如果程序中直接包含了这种函数就可以直接控制返回地址指向他们，而不用通过这种麻烦的方式</span><span class="cs8926E06">)</span><span class="cs9C1B1871">。因为程序是动态链接生成的，所以在程序运行时会调用</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">libc.so (</span><span class="csE3F655E4">程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，</span><span class="cs5BEC2C28">libc.so </span><span class="csE3F655E4">就是其中最基本的一个</span><span class="cs5BEC2C28">)</span><span class="cs9C1B1871">，</span><span class="cs5BEC2C28">libc.so</span><span class="cs8926E06"> </span><span class="cs9C1B1871">是</span><span class="cs8926E06"> linux </span><span class="cs9C1B1871">下</span><span class="cs8926E06"> C </span><span class="cs9C1B1871">语言库中的运行库</span><span class="cs5BEC2C28">glibc</span><span class="cs8926E06"> </span><span class="cs9C1B1871">的动态链接版，并且</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">libc</span><span class="cs8926E06">.</span><span class="cs5BEC2C28">so</span><span class="cs8926E06"> </span><span class="cs9C1B1871">中包含了大量的可以利用的函数，包括</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">system() </span><span class="csE3F655E4">、</span><span class="cs5BEC2C28">execve()</span><span class="cs8926E06"> </span><span class="cs9C1B1871">等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行</span><span class="cs8926E06"> </span><span class="cs5BEC2C28">system(&ldquo;/bin/sh&rdquo;)</span><span class="cs8926E06"> </span><span class="cs9C1B1871">来打开</span><span class="cs8926E06"> shell</span><span class="cs9C1B1871">。这里我们使用</span><span class="cs8926E06">vmmap</span><span class="cs9C1B1871">查看调用的</span><span class="cs8926E06">lib</span><span class="cs9C1B1871">文件有哪些</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image6.png" width="560" height="750" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">注：由于是在模拟器中查找的</span><span class="cs8926E06">lib</span><span class="cs9C1B1871">文件的起始地址，所以和在真机中的地址可能不太一样</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里我们选择具有执行权限的</span><span class="cs8926E06">libc.so.0</span><span class="cs9C1B1871">文件，使用</span><span class="cs8926E06">radare2</span><span class="cs9C1B1871">对</span><span class="cs8926E06">libc.so.0</span><span class="cs9C1B1871">文件进行搜索</span><span class="cs8926E06">system</span><span class="cs9C1B1871">函数</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image7.png" width="560" height="213" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里的</span><span class="cs8926E06">system</span><span class="cs9C1B1871">函数的地址是偏移地址，偏移地址加上</span><span class="cs8926E06">vmmap</span><span class="cs9C1B1871">得到的起始地址就是，我们通过下断点得到</span><span class="cs8926E06">system</span><span class="cs9C1B1871">函数的地址，然后通过计算可以发现地址完全正确</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image8.png" width="560" height="226" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这时我们已经知道了一些关键的地址，那么这个时候我们就需要构造一个</span><span class="cs8926E06"> ROP</span><span class="cs9C1B1871">链，来实现地址的跳转</span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里使用了一款工具</span><span class="cs8926E06">Ropper</span><span class="cs9C1B1871">，因为我们存储的位置位于堆栈，所以查找跟堆栈有关的指针</span><span class="cs8926E06">SP</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image9.png" width="560" height="360" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里我选择了</span><span class="cs8926E06">0x00041308</span><span class="cs9C1B1871">的指令，因为这里有一个关于指令跳转的指令</span><span class="cs8926E06">BLX</span><span class="cs9C1B1871">，如果</span><span class="cs8926E06">r2</span><span class="cs9C1B1871">存的值是</span><span class="cs8926E06">system</span><span class="cs9C1B1871">的地址，那么我们就能跳到</span><span class="cs8926E06">system</span><span class="cs9C1B1871">处，执行系统命令了，并且由于我们的值都存在栈中，所以我们就需要查找和</span><span class="cs8926E06">pop,r2</span><span class="cs9C1B1871">有关的指令</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image10.png" width="560" height="76" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">在</span><span class="cs8926E06">ARM</span><span class="cs9C1B1871">指令集下我们发现两个对</span><span class="cs8926E06">r2</span><span class="cs9C1B1871">的操作，但是后面还跟着别的指令，如果我们使用了某一个，那么我们还得继续寻找能够完整构造</span><span class="cs8926E06">payload</span><span class="cs9C1B1871">的指令。由于</span><span class="cs8926E06">ARM</span><span class="cs9C1B1871">除了有</span><span class="cs8926E06">ARM</span><span class="cs9C1B1871">指令外，还有一个</span><span class="cs8926E06">Thumb</span><span class="cs9C1B1871">指令集，这个指令是</span><span class="cs8926E06">ARM</span><span class="cs9C1B1871">指令集的一个子集，但是在某些方面比</span><span class="cs8926E06">ARM</span><span class="cs9C1B1871">指令集要更有效，我们切换指令集去这里看看符合我们要求的指令</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image11.png" width="560" height="201" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里我们找到了没有其他指令参与并且堆栈操作十分符合我们要求的指令，下面就是我们构造的堆栈的排列方式</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image12.png" width="560" height="182" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">首先排布的是</span><span class="cs8926E06">target1</span><span class="cs9C1B1871">，这条指令就是对栈就行弹出的操作，首先将</span><span class="cs8926E06">system</span><span class="cs9C1B1871">的地址弹出到</span><span class="cs8926E06">r2</span><span class="cs9C1B1871">，然后后面无用的地址弹出到</span><span class="cs8926E06">r6</span><span class="cs9C1B1871">，最后将</span><span class="cs8926E06">target2</span><span class="cs9C1B1871">的地址弹出到</span><span class="cs8926E06">r15</span><span class="cs9C1B1871">中，并且</span><span class="cs8926E06">r15</span><span class="cs9C1B1871">中存储的还是正在取指的地址。紧接着执行</span><span class="cs8926E06">r15</span><span class="cs9C1B1871">所指向的地址，首先将</span><span class="cs8926E06">sp</span><span class="cs9C1B1871">的地址存储到</span><span class="cs8926E06">r0</span><span class="cs9C1B1871">中，然后执行</span><span class="cs8926E06">blx</span><span class="cs9C1B1871">跳转指令并且切换指令集，并且跳转到</span><span class="cs8926E06">r2</span><span class="cs9C1B1871">的地址，也就是</span><span class="cs8926E06">system</span><span class="cs9C1B1871">的地址，那么这时候就成功执行</span><span class="cs8926E06">system</span><span class="cs9C1B1871">函数，到此整个</span><span class="cs8926E06">ROP</span><span class="cs9C1B1871">链也就执行完毕</span></p><h3 class="cs868C439D">
			<a name="Xe1feedad46f27a09c0a3854e9b4afa61444624b"><span class="csD1E291E2">0x04 </span><span class="csD6CA00D2">漏洞复现</span></a></h3>
		<p class="cs40DD2BC9"><span class="cs9C1B1871">这里我们利用的是</span><span class="cs8926E06">exploit-db</span><span class="cs9C1B1871">上的</span><span class="cs8926E06">exp</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image13.png" width="560" height="263" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">设置</span><span class="cs8926E06">rhosts,lhosts</span><span class="cs9C1B1871">和</span><span class="cs8926E06">target</span><span class="cs9C1B1871">，然后直接</span><span class="cs8926E06">exploit</span><span class="cs9C1B1871">，就能直接获得</span><span class="cs8926E06">shell</span><span class="cs9C1B1871">权限，这里我在</span><span class="cs8926E06">vps</span><span class="cs9C1B1871">上执行的</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image14.png" width="560" height="195" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image15.png" width="560" height="449" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">成功执行</span><span class="cs8926E06">ifconfig</span><span class="cs9C1B1871">命令</span></p><h3 class="cs868C439D">
			<a name="X23aacd6b1e72b799e93c00b24a472da2eee7a08"><span class="csD1E291E2">0x05 exp</span><span class="csD6CA00D2">脚本分析</span></a></h3>
		<p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image16.png" width="560" height="205" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里存储就是偏移地址，</span><span class="cs8926E06">libc_base</span><span class="cs9C1B1871">的地址，</span><span class="cs8926E06">system</span><span class="cs9C1B1871">的偏移地址，</span><span class="cs8926E06">gadget1</span><span class="cs9C1B1871">的偏移地址，</span><span class="cs8926E06">gadget2</span><span class="cs9C1B1871">的偏移地址，这些地址就是真机中真正的偏移地址</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image17.png" width="560" height="198" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里就是根据不同的</span><span class="cs8926E06">target</span><span class="cs9C1B1871">生成不同的</span><span class="cs8926E06">payload</span></p><p class="cs40DD2BC9"><span><img src="IOT安全/Cisco/%ef%bc%88CVE-2019-1663%ef%bc%89Cisco%20%e5%a0%86%e6%a0%88%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e_files/image18.png" width="560" height="18" alt="" style="border-width:0px;" /></span></p><p class="cs40DD2BC9"><span class="cs9C1B1871">这里就是我们对</span><span class="cs8926E06">Msf</span><span class="cs9C1B1871">生成的</span><span class="cs8926E06">payload</span><span class="cs9C1B1871">进行输出，可以看到被攻击的设备下载了可以在</span><span class="cs8926E06">ARM</span><span class="cs9C1B1871">平台进行回来的文件，并给与权限并执行，最终创建一个</span><span class="cs8926E06">shell</span></p><h2 class="cs868C439D">
			<a name="参考链接"><span class="cs83F14626">参考链接</span></a></h2>
		<p class="cs6FD73CFB"><span class="cs8926E06"><a class="cs508254C" href="http://lab.xinruisec.com/2019/09/20/CVE-2019-1663-Cisco的多个低端设备的堆栈缓冲区溢出漏洞分析/"><span class="cs4B51D5E4">http://lab.xinruisec.com/2019/09/20/CVE-2019-1663-Cisco%E7%9A%84%E5%A4%9A%E4%B8%AA%E4%BD%8E%E7%AB%AF%E8%AE%BE%E5%A4%87%E7%9A%84%E5%A0%86%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</span></a></span></p></body>
</html>
